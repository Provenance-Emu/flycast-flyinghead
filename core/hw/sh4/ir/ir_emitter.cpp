#include "ir_emitter.h"
#include "hw/sh4/sh4_if.h"  // for Sh4Context, etc.
#include "hw/sh4/modules/mmu.h"
#include "deps/vixl/utils-vixl.h" // For SignExtend
#include "log/Log.h"
#include "types.h"
#include "hw/sh4/sh4_core.h" // for SH4ThrownException and codes
#include "ir_tables.h" // autogenerated opcode -> Op table
#include <mutex>
#include <unordered_map>
#define XXH_STATIC_LINKING_ONLY
#include <xxhash.h>
#include <cstdint>

// ~100k blocks ~= few MB
#define MAX_BLOCKS 100000

// Reuse identical blocks (e.g. BIOS memset stub copied across SDRAM pages)
static std::unordered_map<uint64_t, const sh4::ir::Block*> g_block_sig_cache;

// Work around macro collision: sr is defined as Sh4cntx.sr, so we must undef it
#ifdef sr
#undef sr
#endif
static uint64_t CalcBlockSig(uint32_t pc)
{
    // Hash first 64 bytes (32 instructions) of code at pc, plus SR.T
    uint8_t buf[64];
    for (int i = 0; i < 32; ++i)
    {
        uint16_t op = mmu_IReadMem16(pc + i * 2);
        buf[i * 2]     = static_cast<uint8_t>(op & 0xFF);
        buf[i * 2 + 1] = static_cast<uint8_t>(op >> 8);
    }
    // Include SR.T in the hash to force new blocks when T changes
    // buf[64] = (uint8_t)(p_sh4rcb ? p_sh4rcb->cntx.sr.T : 0);
    return XXH3_64bits(buf, sizeof(buf));
}
#ifdef SH4_RESTORE_SR_MACRO
#define sr Sh4cntx.sr
#endif


namespace sh4 {
namespace ir {

extern std::atomic_bool g_ir_cache_invalidated;
void Emitter::ClearCaches() {
    cache_.clear();
    g_block_sig_cache.clear();
    g_ir_cache_invalidated.store(true, std::memory_order_release);
    INFO_LOG(SH4, "Emitter caches cleared.");
}

// Fast-path decode using autogenerated table. Returns true if handled.
static bool FastDecode(uint16_t raw, uint32_t pc, Instr &ins, Block &blk)
{
    // Special case for FLOAT FPUL,DR6 (0xFC2D)
    if (raw == 0xFC2D) {
        ins.op = Op::FLOAT;
        ins.dst.reg = 12; // For DR6, we need FR12
        ins.dst.isImm = false;
        ins.dst.type = RegType::FGR;
        blk.pcNext = pc + 2;
        DEBUG_LOG(SH4, "FastDecode: Special case for FLOAT FPUL,DR6 (0xFC2D) -> FR12");
        return true;
    }
    // Generic FLOAT FPUL,FRn (0xFn2D)
    if ((raw & 0xF0FF) == 0xF02D) {
        ins.op = Op::FLOAT;
        ins.dst.reg = (raw >> 8) & 0xF;
        ins.dst.isImm = false;
        ins.dst.type = RegType::FGR;
        blk.pcNext = pc + 2;
        DEBUG_LOG(SH4, "FastDecode: FLOAT FPUL,FR%u (0x%04X)", ins.dst.reg, raw);
        return true;
    }

    // ----------------------------------------------------------------
    //  BRA disp12   1010nnnnnnnnnnnn (A***). Delay-slot ⇒ blk.pcNext = pc+4
    // ----------------------------------------------------------------
    if ((raw & 0xF000) == 0xA000) {
        uint32_t imm12 = raw & 0x0FFF;
        int32_t  disp   = static_cast<int32_t>(imm12 << 1);  // byte displacement
        // Sign-extend 13-bit (bit 12 after shift is sign)
        if (disp & 0x1000)
            disp |= ~0x1FFF;
        ins.op     = Op::BRA;
        ins.extra  = disp;
        blk.pcNext = pc + 4;   // execute delay slot, then branch
        DEBUG_LOG(SH4, "FastDecode: BRA raw=0x%04X pc=0x%08X disp=%d (0x%X) target=0x%08X", raw, pc, disp, disp, pc + 4 + disp);
        return true;
    }

    // FNEG FPUL (0xF04D)
    if (raw == 0xF04D) {
        ins.op = Op::FNEG_FPUL;
        blk.pcNext = pc + 2;
        DEBUG_LOG(SH4, "FastDecode: FNEG FPUL (0xF04D)");
        return true;
    }
    // FABS FPUL (0xF05D)
    if (raw == 0xF05D) {
        ins.op = Op::FABS_FPUL;
        blk.pcNext = pc + 2;
        DEBUG_LOG(SH4, "FastDecode: FABS FPUL (0xF05D)");
        return true;
    }
    // FSRRA FRn (0xFn7D)
    if ((raw & 0xF0FF) == 0xF07D) {
        ins.op = Op::FSRRA;
        ins.dst.reg = (raw >> 8) & 0xF;
        ins.dst.isImm = false;
        ins.dst.type = RegType::FGR;
        ins.src1.reg = ins.dst.reg; // Source and destination are the same register
        ins.src1.isImm = false;
        ins.src1.type = RegType::FGR;
        blk.pcNext = pc + 2;
        DEBUG_LOG(SH4, "FastDecode: FSRRA FR%u (0x%04X)", ins.dst.reg, raw);
        return true;
    }

    // FSQRT FRn (0xFnFD) - Single precision square root
    // The pattern is 1111nnnn00001101 where nnnn is the register number
    if ((raw & 0xF0FF) == 0xF0FD && (raw & 0x0F00) != 0x0600) {
        ins.op = Op::FSQRT;
        ins.dst.reg = (raw >> 8) & 0xF;
        ins.dst.isImm = false;
        ins.dst.type = RegType::FGR;
        ins.src1.reg = ins.dst.reg; // Source and destination are the same register
        ins.src1.isImm = false;
        ins.src1.type = RegType::FGR;
        blk.pcNext = pc + 2;
        DEBUG_LOG(SH4, "FastDecode: FSQRT FR%u (0x%04X)", ins.dst.reg, raw);
        return true;
    }

    // FSCA FPUL,DRn (0xF6FD) - Sine and cosine of angle in FPUL
    // The pattern is 1111011011111101 where n is the even register number
    if (raw == 0xF6FD) {
        ins.op = Op::FSCA;
        ins.dst.reg = 6; // DR3 = FR6:FR7 pair
        ins.dst.isImm = false;
        ins.dst.type = RegType::FGR;
        blk.pcNext = pc + 2;
        DEBUG_LOG(SH4, "FastDecode: FSCA FPUL,DR3 (0x%04X)", raw);
        return true;
    }

    // Absolute first: handle NOP (0x0000) and SYNC/UNDEF NOP variant (0x0009)
    if (raw == 0x0000 || raw == 0x0009)
    {
        ins.op = Op::NOP;
        blk.pcNext = pc + 2;
        return true;
    }
    // Quick manual overrides for common ops missing from the autogenerated table
    // SHLL Rn (0x4n08)
    if ((raw & 0xF0FF) == 0x4008)
    {
        uint8_t n = (raw >> 8) & 0xF;
        ins.op = Op::SHLL;
        ins.dst.isImm = false;
        ins.dst.reg = n;
        blk.pcNext = pc + 2;
        return true;
    }
    // MOV.B Rm,@Rn (0x2nm0)
    else if ((raw & 0xF00F) == 0x2000)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::STORE8;
        ins.src1 = {false, m};
        ins.src2 = {false, n};
        ins.extra = 0;
        blk.pcNext = pc + 2;
        return true;
    }
    // MOV.W Rm,@Rn (0x2nm1)
    else if ((raw & 0xF00F) == 0x2001)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::STORE16;
        ins.src1 = {false, m};
        ins.src2 = {false, n};
        ins.extra = 0;
        blk.pcNext = pc + 2;
        return true;
    }
    // MOV.L Rm,@Rn (0x2nm2)
    else if ((raw & 0xF00F) == 0x2002)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::STORE32;
        ins.src1 = {false, m};
        ins.src2 = {false, n};
        ins.extra = 0;
        blk.pcNext = pc + 2;
        return true;
    }
    // MOV.B Rm,@-Rn (0x2nm4)
    else if ((raw & 0xF00F) == 0x2004)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::STORE8_PREDEC;
        ins.dst.isImm = false;
        ins.dst.reg = n;
        ins.src1.isImm = false;
        ins.src1.reg = m;
        ins.src2.isImm = false;
        ins.src2.reg = n;
        blk.pcNext = pc + 2;
        return true;
    }
    // MOV.W Rm,@-Rn (0x2nm5)
    else if ((raw & 0xF00F) == 0x2005)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::STORE16_PREDEC;
        ins.dst.isImm = false;
        ins.dst.reg = n;
        ins.src1.isImm = false;
        ins.src1.reg = m;
        ins.src2.isImm = false;
        ins.src2.reg = n;
        blk.pcNext = pc + 2;
        return true;
    }
    // MOV.L Rm,@-Rn (0x2nm6)
    else if ((raw & 0xF00F) == 0x2006)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::STORE32_PREDEC;
        ins.dst.isImm = false;
        ins.dst.reg = n;
        ins.src1.isImm = false;
        ins.src1.reg = m;
        ins.src2.isImm = false;
        ins.src2.reg = n;
        blk.pcNext = pc + 2;
        return true;
    }
    // DIV0S Rm,Rn (0x2nm7)
    else if ((raw & 0xF00F) == 0x2007)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::DIV0S;
        ins.dst.isImm = false;
        ins.dst.reg = n;
        ins.src1.isImm = false;
        ins.src1.reg = m;
        INFO_LOG(SH4, "FastDecode: Decoded DIV0S R%u,R%u (0x%04X) at PC=%08X",
                m, n, raw, pc);
        blk.pcNext = pc + 2;
        return true;
    }
    // MOV.B Rm,@-Rn (0x2nm8)
    else if ((raw & 0xF00F) == 0x2008)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::MOV_B_REG_PREDEC;
        ins.dst.isImm = false;
        ins.dst.reg = n;
        ins.src1.isImm = false;
        ins.src1.reg = m;
        ins.src2.isImm = false;
        ins.src2.reg = n;
        blk.pcNext = pc + 2;
        return true;
    }
    // SHL2/8/16 Rn variants (0x4n08,0x4n18,0x4n28)
    else if ((raw & 0xF00F) == 0x4008)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t idx = (raw >> 4) & 0xF;
        uint8_t shift = (idx == 0) ? 2 : (idx == 1 ? 8 : (idx == 2 ? 16 : 1));
        ins.op = Op::SHL;
        ins.dst.isImm = false;
        ins.dst.reg = n;
        ins.extra = shift;
        blk.pcNext = pc + 2;
        return true;
    }
    // SHLR2/8/16 Rn variants (0x4n09,0x4n19,0x4n29)
    else if ((raw & 0xF00F) == 0x4009)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t idx = (raw >> 4) & 0xF;
        uint8_t shift = (idx == 0) ? 2 : (idx == 1 ? 8 : 16);
        ins.op = Op::SHR_OP;
        ins.dst.isImm = false;
        ins.dst.reg = n;
        ins.extra = shift;
        blk.pcNext = pc + 2;
        return true;
    }
    // SAR2/8/16 Rn variants (0x4n0A,0x4n1A,0x4n2A)
    else if ((raw & 0xF00F) == 0x400A)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t idx = (raw >> 4) & 0xF;
        uint8_t shift = (idx == 0) ? 2 : (idx == 1 ? 8 : 16);
        ins.op = Op::SAR_OP;
        ins.dst.isImm = false;
        ins.dst.reg = n;
        ins.extra = shift;
        blk.pcNext = pc + 2;
        return true;
    }
    // STC Rm_BANK,Rn  (0x00mn1A) – banked register store
    else if ((raw & 0x00FF) == 0x001A)
    {
        uint8_t n = (raw >> 8) & 0xF;          // destination general register
        uint8_t m_bank = (raw >> 4) & 0xF;     // source bank register index
        ins.op = Op::STC;
        ins.dst.isImm = false; ins.dst.reg = n;
        ins.extra = 8 + m_bank;                // executor expects bank index in extra
        blk.pcNext = pc + 2;
        return true;
    }
    // SHLR1 Rn (0x4n01)
    else if ((raw & 0xF0FF) == 0x4001)
    {
        uint8_t n = (raw >> 8) & 0xF;
        ins.op = Op::SHR1;
        ins.dst.isImm = false; ins.dst.reg = n;
        blk.pcNext = pc + 2;
        return true;
    }
    // TST #imm8, R0  (0xC8ii)
    else if ((raw & 0xFF00) == 0xC800)
    {
        uint8_t imm = raw & 0xFF;
        ins.op = Op::TST_IMM;
        ins.src1.isImm = true;  ins.src1.imm = imm;
        blk.pcNext = pc + 2;
        return true;
    }
    // MOV.W @(disp,Rm),R0   Encoding 1000 0101 mmmm dddd (opcode 0x85md)
    // Loads a 16-bit word from @(disp*2,Rm) into R0.
    else if ((raw & 0xFF00) == 0x8500) {
        uint8_t rm_base_reg = (raw >> 4) & 0xF;   // bits 7-4 = Rm
        uint8_t disp4       = raw & 0xF;          // bits 3-0 = disp4

        ins.op   = Op::LOAD16;                    // 16-bit load
        ins.dst  = {false, 0};                    // destination is R0
        ins.src1 = {false, rm_base_reg};          // base register Rm
        ins.extra = static_cast<uint32_t>(disp4) * 2; // displacement bytes (×2)
        printf("[IR_EMITTER_DEBUG] Decoded MOV.W @(disp=%u,R%d),R0  raw=0x%04X pc=0x%08X\n", disp4, rm_base_reg, raw, pc);
// #endif
        blk.pcNext = pc + 2;
        return true;
    }
    // MOV.W @(disp,Rm),R0 0x5xxx pattern (destination fixed R0, word displacement*2)
    // Must appear before other 0x5000 handlers to avoid conflicts
    else if ((raw & 0xF000) == 0x5000 && ((raw & 0x0F00) == 0x0000) && ((raw & 0xF) != 0x2) && ((raw & 0xF) != 0x1)) {
        uint8_t rm = (raw >> 4) & 0xF;     // Rm in bits 7-4
        uint8_t disp4 = raw & 0xF;         // disp low nibble
        uint8_t disp_high = (raw >> 8) & 0xF; // bits 11-8 are zero (dest), reuse as high nibble of disp if needed
        uint8_t disp8 = static_cast<uint8_t>((disp_high << 4) | disp4);

        ins.op = Op::LOAD16;               // 16-bit load (sign-extended)
        ins.dst = {false, 0};              // destination is R0
        ins.src1 = {false, rm};            // base register Rm
        ins.extra = static_cast<uint32_t>(disp8) * 2; // displacement in bytes

        INFO_LOG(SH4, "FastDecode: MOV.W @(%u,R%u),R0 (0x%04X) at PC=%08X", ins.extra, rm, raw, pc);
        blk.pcNext = pc + 2;
        return true;
    }

    // 0x5000 patterns can be either:
    // 1. MOV.L @(disp,Rm),Rn (0x5nm2) - LOAD operation
    // 2. MOV.L Rm,@(disp,Rn) (0x5nm1) - STORE operation
    else if ((raw & 0xF000) == 0x5000) {
        printf("[IR_EMITTER_DEBUG] FastDecode: Entered 0x5000 block for raw=0x%04X, pc=0x%08X\n", raw, pc); fflush(stdout);
        uint8_t rn = (raw >> 8) & 0xF;     // Rn in bits 8-11
        uint8_t rm = (raw >> 4) & 0xF;    // Rm in bits 4-7
        uint8_t disp = raw & 0xF;

        // Check the lowest bit to distinguish between LOAD (2) and STORE (1)
        if ((raw & 0xF) == 0x2) {
            // MOV.L @(disp,Rm),Rn (0x5nm2) - LOAD operation
            ins.op = Op::LOAD32;
            ins.dst = {false, rn};            // Destination is Rn
            ins.src1 = {false, rm};          // Base address from Rm
            ins.extra = disp * 4;            // Displacement in ins.extra (disp * 4 bytes)

            INFO_LOG(SH4, "FastDecode: Decoded MOV.L @(%u,R%u),R%u (LOAD) (0x%04X) at PC=%08X",
                    disp * 4, rm, rn, raw, pc);
        } else if ((raw & 0xF) == 0x1) {
            // MOV.L Rm,@(disp,Rn) (0x5nm1) - STORE operation
            ins.op = Op::STORE32;
            // For STORE32, src1 holds the value (Rm) and src2 is the base address (Rn)
            ins.src1 = {false, rm};          // Value to store (Rm)
            ins.src2 = {false, rn};          // Base address register (Rn)
            ins.extra = disp * 4;            // Byte displacement (disp * 4)

            INFO_LOG(SH4, "FastDecode: Decoded MOV.L R%u,@(%u,R%u) (STORE) (0x%04X) at PC=%08X",
                    rm, disp * 4, rn, raw, pc);
        } else {
            // Not a recognized 0x5000 pattern in FastDecode
            return false;
        }

        blk.pcNext = pc + 2;
        return true;
    }
    // CMP/EQ #imm,R0 0x88ii (ii=imm8)
    else if ((raw & 0xFF00) == 0x8800) {
        printf("[IR_EMITTER_DEBUG] FastDecode: Entered 0x8800 block for raw=0x%04X, pc=0x%08X\n", raw, pc); fflush(stdout);
        int8_t imm8 = raw & 0xFF;              // imm8 is in bits 0-7 (sign-extended)

        ins.op = Op::CMP_EQ_IMM;                // Use CMP_EQ_IMM operation
        ins.dst = {false, 0};                   // Compare with R0
        ins.src1 = {true, 0};                   // No register source, immediate value
        ins.extra = imm8;                       // Immediate value in ins.extra

        INFO_LOG(SH4, "FastDecode: Decoded CMP/EQ #%d,R0 (0x%04X) at PC=%08X",
                imm8, raw, pc);
        blk.pcNext = pc + 2;
        return true;
    }
    // MOV.B @(disp,Rm),R0 0x84md
    else if ((raw & 0xFF00) == 0x8400) {
        printf("[IR_EMITTER_DEBUG] FastDecode: Entered 0x8400 block for raw=0x%04X, pc=0x%08X\n", raw, pc); fflush(stdout);
        uint8_t disp4 = raw & 0xF;              // disp4 is in bits 0-3
        uint8_t m_reg = (raw >> 4) & 0xF;       // Rm is in bits 4-7

        ins.op = Op::LOAD8;                     // Use generic LOAD8
        ins.dst = {false, 0};                    // Destination is always R0
        ins.src1 = {false, m_reg};               // Base address from Rm
        ins.extra = disp4;                       // Displacement in ins.extra (disp bytes)

        INFO_LOG(SH4, "FastDecode: Decoded LOAD8 @(%u,R%u),R0 (0x%04X) at PC=%08X",
                disp4, m_reg, raw, pc);
        blk.pcNext = pc + 2;
        return true;
    }
    // MOV.W @(disp,Rm),R0 0x85md
    else if ((raw & 0xFF00) == 0x8500) {
        printf("[IR_EMITTER_DEBUG] FastDecode: Entered 0x8500 block for raw=0x%04X, pc=0x%08X\n", raw, pc); fflush(stdout);
        uint8_t disp4 = raw & 0xF;              // disp4 is in bits 0-3
        uint8_t m_reg = (raw >> 4) & 0xF;       // Rm is in bits 4-7

        ins.op = Op::LOAD16;                    // Use generic LOAD16
        ins.dst = {false, 0};                    // Destination is always R0
        ins.src1 = {false, m_reg};               // Base address from Rm
        ins.extra = disp4 * 2;                   // Displacement in ins.extra (disp * 2 bytes)

        INFO_LOG(SH4, "FastDecode: Decoded LOAD16 @(%u,R%u),R0 (0x%04X) at PC=%08X",
                disp4 * 2, m_reg, raw, pc);
        blk.pcNext = pc + 2;
        return true;
    }
    // MOV Rm,Rn 0x6nm3 (register to register)
    else if ((raw & 0xF00F) == 0x6003) {
        INFO_LOG(SH4, "FastDecode: Entered 0x6003 block for raw=0x%04X, pc=0x%08X\n", raw, pc);
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::MOV_REG;
        ins.dst = {false, n};
        ins.src1 = {false, m};
        blk.pcNext = pc + 2;
        return true;
    }
    // MOV.L @Rm+,Rn 0x6nm6  (post-increment long load)
    else if ((raw & 0xF00F) == 0x6006) {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::LOAD32_POST;
        ins.dst = {false, n};
        ins.src1 = {false, m};
        blk.pcNext = pc + 2;
        return true;
    }
    // MOV.W @Rm+,Rn 0x6nm5
    else if ((raw & 0xF00F) == 0x6005) {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::LOAD16_POST;
        ins.dst = {false, n};
        ins.src1 = {false, m};
        blk.pcNext = pc + 2;
        return true;
    }
    // MOV.B @(Rm,Rn),R0  (0x00mn2) -> R0 = mem[Rm+Rn]
    // For 0x0082: Rm=R0 (n=0), Rn=R8 (m=8) -> R0 = mem[R0+R8]
    else if ((raw & 0xFF0F) == 0x0002) // Mask for 0000nnnnmmmm0010
    {
        uint8_t rm_idx = (raw >> 8) & 0xF; // Manual: Rm, our nnnn field
        uint8_t rn_idx = (raw >> 4) & 0xF; // Manual: Rn, our mmmm field

        ins.op = Op::LOAD8;      // The operation is a byte load to R0
        ins.dst.isImm = false;
        ins.dst.reg = 0;         // Destination is R0
        ins.dst.type = RegType::GPR;

        ins.src1.isImm = false;
        ins.src1.reg = rm_idx;    // Base register (Rm)
        ins.src1.type = RegType::GPR;

        ins.src2.isImm = false;
        ins.src2.reg = rn_idx;    // Offset register (Rn)
        ins.src2.type = RegType::GPR;
        // Executor for LOAD8 will check if src2 is used for reg+reg addressing.

        blk.pcNext = pc + 2;
        return true;
    }
    // MOV.B @Rm+,Rn 0x6nm4
    else if ((raw & 0xF00F) == 0x6004) {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::LOAD8_POST;
        ins.dst = {false, n};
        ins.src1 = {false, m};
        blk.pcNext = pc + 2;
        return true;
    }


    // MOV.L @(disp,PC),Rn 0xD000 | Rn<<8 | disp8
    // Note: Tests use Rn(r) which is r<<8, so we must extract from bits 8-11 to match test expectations
    else if ((raw & 0xF000) == 0xD000)
    {
        uint8_t n = (raw >> 8) & 0xF;  // Match test expectations: Rn is in bits 8-11
        uint8_t disp = raw & 0xFF;
        ins.op = Op::LOAD32_PC;
        ins.dst = {false, n};
        ins.extra = disp;
        blk.pcNext = pc + 2;
        return true;
    }
    // MOV.W @(disp,PC),Rn 0x9000 | Rn<<8 | disp8
    // Note: Tests use Rn(r) which is r<<8, so we must extract from bits 8-11 to match test expectations
    else if ((raw & 0xF000) == 0x9000)
    {
        uint8_t n = (raw >> 8) & 0xF;  // Match test expectations: Rn is in bits 8-11
        uint8_t disp = raw & 0xFF;
        ins.op = Op::LOAD16_PC;
        ins.dst = {false, n};
        ins.extra = disp;  // Pass raw disp8 for executor to use
        blk.pcNext = pc + 2;
        return true;
    }

    else if ((raw & 0xF000) == 0xE000) // MOV #imm,Rn
    {
        uint8_t n = (raw >> 8) & 0xF;
        ins.op = Op::MOV_IMM;
        ins.dst = {false, n};
        ins.src1.isImm = true;
        ins.src1.imm = static_cast<int8_t>(raw & 0xFF);
        blk.pcNext = pc + 2;
        return true;
    }

    // LDC Rm, SR (0x4m1E)
    else if ((raw & 0xF0FF) == 0x401E)
    {
        uint8_t m = (raw >> 8) & 0xF; // Rm is in the 'n' field position for 0x4n1E pattern
        ins.op = Op::LDC_SR;
        ins.src1.isImm = false;
        ins.src1.reg = m;
        ins.src1.type = RegType::GPR;
        // SR is the implicit destination
        blk.pcNext = pc + 2;
        return true;
    }
    // STC SR, Rn (0x0n2E)
    else if ((raw & 0xF0FF) == 0x002E)
    {
        uint8_t n = (raw >> 8) & 0xF;
        ins.op = Op::STC_SR;
        ins.dst.isImm = false;
        ins.dst.reg = n;
        ins.dst.type = RegType::GPR;
        // SR is the implicit source
        blk.pcNext = pc + 2;
        return true;
    }
    // FRCHG 0xFBFD
    else if (raw == 0xFBFD)
    {
        ins.op = Op::FRCHG;
        // FRCHG has no operands
        blk.pcNext = pc + 2;
        return true;
    }
    // CLRT (0x0008)
    else if (raw == 0x0008)
    {
        ins.op = Op::CLRT;
        blk.pcNext = pc + 2;
        return true;
    }
    // MUL.L Rm,Rn (0x0007)
    else if ((raw & 0xF00F) == 0x0007)
    {
        uint8_t n = (raw >> 8) & 0xF; // Extract n (bits 8-11)
        uint8_t m = (raw >> 4) & 0xF; // Extract m (bits 4-7)
        ins.op = Op::MUL_L;
        ins.dst.isImm = false; ins.dst.reg = n;
        ins.src1.isImm = false; ins.src1.reg = m;
        INFO_LOG(SH4, "FastDecode: Decoded MUL.L R%u,R%u (0x%04X) at PC=%08X",
                 ins.src1.reg, ins.dst.reg, raw, pc);
        blk.pcNext = pc + 2;
        return true;
    }
    // SETT (0x0018)
    else if (raw == 0x0018)
    {
        ins.op = Op::SETT;
        blk.pcNext = pc + 2;
        return true;
    }
    // DIV0U (0x0019)
    else if (raw == 0x0019)
    {
        ins.op = Op::DIV0U;
        INFO_LOG(SH4, "FastDecode: Decoded DIV0U (0x%04X) at PC=%08X", raw, pc);
        blk.pcNext = pc + 2;
        return true;
    }
    // CLRS (0x0048)
    else if (raw == 0x0048)
    {
        ins.op = Op::CLRS;
        blk.pcNext = pc + 2;
        return true;
    }

    // ADDC Rm, Rn (0x3nmE) - Add with carry
    else if ((raw & 0xF00F) == 0x300E)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        printf("[IR_EMITTER][ADDC] FastDecode: raw=0x%04X pc=0x%08X n=%u m=%u\n", raw, pc, n, m);
        ins.op = Op::ADDC;
        ins.dst.isImm = false; ins.dst.reg = n;
        ins.src1.isImm = false; ins.src1.reg = m;
        printf("[IR_EMITTER][ADDC] ins.dst: isImm=%d reg=%u, ins.src1: isImm=%d reg=%u\n", ins.dst.isImm, ins.dst.reg, ins.src1.isImm, ins.src1.reg);
        blk.pcNext = pc + 2;
        DEBUG_LOG(SH4, "[IR_EMITTER][ADDC] blk.pcNext=0x%08X", blk.pcNext);
        return true;
    }

    // ADDV Rm, Rn (0x3nmF)
    else if ((raw & 0xF00F) == 0x300F) {
        DEBUG_LOG(SH4, "In ADDV fast decode.");
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::ADDV;
        ins.dst.isImm = false; ins.dst.reg = n;
        ins.src1.isImm = false; ins.src1.reg = m;
        blk.pcNext = pc + 2;
        return true;
    }
    // SUBC Rm, Rn (0x3nmA)
    else if ((raw & 0xF00F) == 0x300A)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::SUBC;
        ins.dst.isImm = false; ins.dst.reg = n;
        ins.src1.isImm = false; ins.src1.reg = m;
        blk.pcNext = pc + 2;
        return true;
    }
    // SUBV Rm, Rn (0x3nmB)
    else if ((raw & 0xF00F) == 0x300B)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::SUBV;
        ins.dst.isImm = false; ins.dst.reg = n;
        ins.src1.isImm = false; ins.src1.reg = m;
        blk.pcNext = pc + 2;
        return true;
    }
    // NEG Rm, Rn (0x6nmB)
    else if ((raw & 0xF00F) == 0x600B)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::NEG;
        ins.dst.isImm = false; ins.dst.reg = n;
        ins.src1.isImm = false; ins.src1.reg = m;
        blk.pcNext = pc + 2;
        return true;
    }
    // NEGC Rm, Rn (0x6nmA)
    else if ((raw & 0xF00F) == 0x600A)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::NEGC;
        ins.dst.isImm = false; ins.dst.reg = n;
        ins.src1.isImm = false; ins.src1.reg = m;
        blk.pcNext = pc + 2;
        return true;
    }
    // EXTS.W Rm, Rn (0x6nmF)
    else if ((raw & 0xF00F) == 0x600F)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::EXTS_W;
        ins.dst.isImm = false; ins.dst.reg = n;
        ins.src1.isImm = false; ins.src1.reg = m;
        blk.pcNext = pc + 2;
        return true;
    }
    // EXTU.W Rm, Rn (0x6nmD)
    else if ((raw & 0xF00F) == 0x600D)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::EXTU_W;
        ins.dst.isImm = false; ins.dst.reg = n;
        ins.src1.isImm = false; ins.src1.reg = m;
        blk.pcNext = pc + 2;
        return true;
    }
    // EXTS.B Rm, Rn (0x6nmE)
    else if ((raw & 0xF00F) == 0x600E)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::EXTS_B;
        ins.dst.isImm = false; ins.dst.reg = n;
        ins.src1.isImm = false; ins.src1.reg = m;
        blk.pcNext = pc + 2;
        return true;
    }
    // EXTU.B Rm, Rn (0x6nmC)
    else if ((raw & 0xF00F) == 0x600C)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::EXTU_B;
        ins.dst.isImm = false; ins.dst.reg = n;
        ins.src1.isImm = false; ins.src1.reg = m;
        blk.pcNext = pc + 2;
        return true;
    }
    // SETS (0x0058)
    else if (raw == 0x0058)
    {
        ins.op = Op::SETS;
        blk.pcNext = pc + 2;
        return true;
    }
    // FSTS FPUL,FRn (0xF08D)
    else if ((raw & 0xFF0F) == 0xF00D)
    {
        uint8_t n = (raw >> 8) & 0xF;
        ins.op = Op::FSTS;
        ins.src1.isImm = false;
        ins.src1.reg = n;
        ins.src1.type = RegType::FGR;
        blk.pcNext = pc + 2;
        return true;
    }
    // FLDI1 FRn (0xF39D) - Load immediate 1.0 into FRn
    else if (raw == 0xF39D)
    {
        uint8_t n = (raw >> 8) & 0xF;
        ins.op = Op::FLDI1;
        ins.dst.isImm = false;
        ins.dst.reg = n;
        ins.dst.type = RegType::FGR;
        blk.pcNext = pc + 2;
        return true;
    }
    // FLDS FRm,FPUL (0xF21D) - Store FRm into FPUL
    else if (raw == 0xF21D)
    {
        uint8_t m = (raw >> 8) & 0xF;
        ins.op = Op::FLDS;
        ins.src1.isImm = false;
        ins.src1.reg = m;
        ins.src1.type = RegType::FGR;
        DEBUG_LOG(SH4, "FastDecode: FLDS FR%u, FPUL (0x%04X) at PC=0x%08X", m, raw, pc);
        blk.pcNext = pc + 2;
        return true;
    }
    // FSTS FPUL,FRn (0xF60D) - Store FPUL into FRn
    else if (raw == 0xF60D)
    {
        uint8_t n = (raw >> 8) & 0xF;
        ins.op = Op::FSTS;
        ins.dst.isImm = false;
        ins.dst.reg = n;
        ins.dst.type = RegType::FGR;
        DEBUG_LOG(SH4, "FastDecode: FSTS FPUL, FR%u (0x%04X) at PC=0x%08X", n, raw, pc);
        blk.pcNext = pc + 2;
        return true;
    }
    // FNEG FRn (0xFB4D) - Negate FRn
    else if (raw == 0xFB4D)
    {
        uint8_t n = (raw >> 8) & 0xF;
        ins.op = Op::FNEG;
        ins.dst.isImm = false;
        ins.dst.reg = n;
        ins.dst.type = RegType::FGR;
        DEBUG_LOG(SH4, "FastDecode: FNEG FR%u (0x%04X) at PC=0x%08X", n, raw, pc);
        blk.pcNext = pc + 2;
        return true;
    }
    // FTRC FRm,FPUL (0xFm3D) - Float to integer conversion
    else if ((raw & 0xF0FF) == 0xF03D)
    {
        uint8_t m = (raw >> 8) & 0xF;
        ins.op = Op::FTRC;
        ins.src1.isImm = false;
        ins.src1.reg = m;
        ins.src1.type = RegType::FGR;
        blk.pcNext = pc + 2;
        return true;
    }
    // FMAC FR0,FRm,FRn (0xFnmE) - Floating MAC: FRn = FRn + FR0 * FRm
    else if ((raw & 0xF00F) == 0xF00E)
    {
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;
        ins.op = Op::FMAC;
        ins.dst.isImm = false;
        ins.dst.reg = n;
        ins.dst.type = RegType::FGR;
        ins.src1.isImm = false;
        ins.src1.reg = m;
        ins.src1.type = RegType::FGR;
        // FR0 is implicit in this instruction
        DEBUG_LOG(SH4, "FastDecode: FMAC FR0, FR%u, FR%u (0x%04X) at PC=0x%08X", m, n, raw, pc);
        blk.pcNext = pc + 2;
        return true;
    }

    Op op = static_cast<Op>(kEmitterTable[raw]);
    if (op == Op::ILLEGAL)
        return false;

    uint8_t n = (raw >> 8) & 0xF;
    uint8_t m = (raw >> 4) & 0xF;

    switch (op)
    {
    case Op::NOP:
        ins.op = Op::NOP;
        blk.pcNext = pc + 2;
        return true;

    case Op::MOV_REG:
        ins.op = Op::MOV_REG;
        ins.dst = {false, n};
        ins.src1 = {false, m};
        blk.pcNext = pc + 2;
        return true;

    case Op::MOV_IMM:
        ins.op = Op::MOV_IMM;
        ins.dst = {false, n};
        ins.src1.isImm = true;
        ins.src1.imm = static_cast<int8_t>(raw & 0xFF);
        blk.pcNext = pc + 2;
        return true;

    case Op::ADD_IMM:
        ins.op = Op::ADD_IMM;
        ins.dst = {false, n};
        ins.src1.isImm = true;
        ins.src1.imm = static_cast<int8_t>(raw & 0xFF);
        blk.pcNext = pc + 2;
        return true;

    case Op::SUB:
    case Op::AND_REG:
    case Op::OR_REG:
    case Op::XOR_REG:
    case Op::NOT:
    case Op::NEG:
    case Op::EXTU_B:
    case Op::EXTU_W:
    case Op::EXTS_B:
    case Op::EXTS_W:
        ins.op = op;
        ins.dst = {false, n};
        ins.src1 = {false, m};
        blk.pcNext = pc + 2;
        return true;

    case Op::JSR:
        ins.op = Op::JSR;
        ins.src1.isImm = false;
        ins.src1.reg = n;
        ins.src1.type = RegType::GPR;
        blk.pcNext = pc + 2;
        return true;

    case Op::BRA:
    {
        uint32_t imm12 = raw & 0x0FFF;
        int32_t disp = static_cast<int32_t>(imm12 << 1); // convert to byte displacement
        // Sign-extend 13-bit value (bit 12 is sign after shift)
        if (disp & 0x1000)
            disp |= ~0x1FFF;
        ins.op = Op::BRA;
        ins.extra = disp;
        blk.pcNext = pc + 4;
        return true;
    }
    case Op::BT:
    case Op::BF:
    {
        int8_t disp = raw & 0xFF;
        int32_t d = disp << 1;
        ins.op = op;
        ins.extra = d;
        return true;
    }
    default:
        INFO_LOG(SH4, "FastDecode: Op %d (from raw 0x%04X at PC=0x%08X) fell into default. Returning false.", static_cast<int>(op), raw, pc);
        return false; // not yet implemented; let manual path try
    }
}

Block& Emitter::CreateNew(uint32_t pc) {
    // Simple global cap on total cached blocks to avoid runaway memory usage.
    static constexpr size_t kMaxBlocks = MAX_BLOCKS;
    if (cache_.size() > kMaxBlocks)
    {
        // Clear caches
        ClearCaches();
    }

    auto [it, inserted] = cache_.emplace(pc, Block{});
    Block& blk = it->second;
    if (inserted)
    {
        // Deduplicate identical code blocks to avoid runaway allocations.
        uint64_t sig = CalcBlockSig(pc);
        if (auto itSig = g_block_sig_cache.find(sig); itSig != g_block_sig_cache.end())
        {
            // Point cache entry at existing block and discard placeholder.
            return const_cast<Block&>(*itSig->second);
        }

        blk.pcStart = pc;
        INFO_LOG(SH4, "Emitter::CreateNew: Entered for PC=0x%08X", pc);
        fflush(stdout);
        if (pc == 0xAC000000) {
            INFO_LOG(SH4, "Emitter::CreateNew: Processing target PC=0xAC000000");
            fflush(stdout);
        }
        uint16_t raw = mmu_IReadMem16(pc);
        INFO_LOG(SH4, "Emitter::CreateNew: PC=0x%08X, raw_opcode=0x%04X", pc, raw);
        fflush(stdout);
    if (pc == 0x8C00B6B8 || pc == 0x8C00B6BA || pc == 0x8C00B6BC) {
        INFO_LOG(SH4, "Emitter::CreateNew: At critical PC=%08X, raw=0x%04X", pc, raw);
    }
    // INFO_LOG(SH4, "Emitter::CreateNew: PC=%08X, raw=0x%04X", pc, raw);

        // Simple decode for a few key opcodes
        uint8_t n = (raw >> 8) & 0xF;
        uint8_t m = (raw >> 4) & 0xF;

        Instr ins{};
        // clear operands
        ins.dst = {};
        ins.src1 = {};
        ins.src2 = {};
        bool decoded = false;

        if (raw == 0xFFFE || raw == 0xFFFF)
        {
            static Block template_nop_end_block;
            if (template_nop_end_block.code.empty())
            {
                Instr nop_ins{}; nop_ins.op = Op::NOP; template_nop_end_block.code.push_back(nop_ins);
                Instr end_ins{}; end_ins.op = Op::END; template_nop_end_block.code.push_back(end_ins);
            }

            // Populate the actual block in the cache (blk) using the template
            blk = template_nop_end_block; // Copy IR instructions {NOP, END}
            blk.pcStart = pc;
            blk.pcNext  = pc + 2;
            blk.code[0].pc = pc;
            blk.code[0].raw = raw;
            blk.code[1].pc = pc + 2;
            // blk.code[1].raw = 0; // END raw value, if needed for Op::END

            // 'blk' is cache_[pc]. It's now populated. If signature caching is used for these NOP blocks,
            // g_block_sig_cache[sig] = &blk; would happen after this 'if' structure, before returning blk.
            // For now, this path correctly populates blk (cache_[pc]) and returns it.
            return blk;
        }

        if (raw == 0x0000 || raw == 0x0009)
        {
            // Insert NOP first
            ins.op = Op::NOP;
            ins.pc = pc;
            ins.raw = raw;
            blk.code.push_back(ins);

            // Decode following instruction so sequential Step(2) tests work
            uint32_t next_pc_addr = pc + 2;
            uint16_t next_raw = mmu_IReadMem16(next_pc_addr);

            Instr next_ins{}; // zero-initialised avoids stale fields
            Block scratch_blk; // temporary for FastDecode (fills blk.pcNext)
            bool ok = FastDecode(next_raw, next_pc_addr, next_ins, scratch_blk);

            if (ok && next_ins.op != Op::ILLEGAL)
            {
                next_ins.pc  = next_pc_addr;
                next_ins.raw = next_raw;
                blk.code.push_back(next_ins);
                blk.pcNext = scratch_blk.pcNext ? scratch_blk.pcNext : (next_pc_addr + 2);
            }
            else if ((next_raw & 0xFF00) == 0xC700) // MOVA @(disp,PC),R0
            {
                uint8_t disp = next_raw & 0xFF;
                uint32_t ea = (next_pc_addr & ~3u) + 4u + (static_cast<uint32_t>(disp) << 2);

                next_ins = Instr{};
                next_ins.op = Op::MOV_IMM;
                next_ins.dst.isImm = false; next_ins.dst.reg = 0;
                next_ins.src1.isImm = true; next_ins.src1.imm = static_cast<int32_t>(ea);
                next_ins.pc = next_pc_addr;
                next_ins.raw = next_raw;
                blk.code.push_back(next_ins);
                blk.pcNext = next_pc_addr + 2;
            }
            else
            {
                blk.pcNext = next_pc_addr; // could not decode
            }

                        // Coalescing loop: keep decoding straight-line instructions
            uint32_t curr_pc_addr = blk.pcNext == 0 ? (pc + 2) : blk.pcNext;
            static constexpr size_t kMaxInstrPerBlock = 64;
            while (blk.code.size() < kMaxInstrPerBlock)
            {
                // Stop if previous instruction was a control-flow that already changed pcNext (branch, rts, etc.)
                if (blk.pcNext != curr_pc_addr)
                    break; // pcNext already diverged – control-flow boundary reached

                uint16_t next_raw = mmu_IReadMem16(curr_pc_addr);
                Instr next_ins{}; // clear
                Block scratch_blk; // temporary for FastDecode (fills blk.pcNext)
                bool decoded_ok = FastDecode(next_raw, curr_pc_addr, next_ins, scratch_blk);

                if (!decoded_ok || next_ins.op == Op::ILLEGAL)
                    break; // do not extend past undecoded/illegal instruction (executor will trap if needed)

                // If FastDecode handled, next_ins may lack PC/raw details until we set them.
                next_ins.pc  = curr_pc_addr;
                next_ins.raw = next_raw;
                blk.code.push_back(next_ins);

                // Update blk.pcNext to whatever FastDecode decided – for straight-line it will be curr_pc+2.
                blk.pcNext = scratch_blk.pcNext ? scratch_blk.pcNext : (curr_pc_addr + 2);

                // Handle delay slot: if instruction has delay slot (pcNext == curr_pc + 4)
                if (blk.pcNext == curr_pc_addr + 4)
                {
                    uint32_t slot_pc  = curr_pc_addr + 2;
                    uint16_t slot_raw = mmu_IReadMem16(slot_pc);
                    Instr slot{};
                    Block dummy_slot_blk;
                    bool slot_ok = FastDecode(slot_raw, slot_pc, slot, dummy_slot_blk);
                    if (!slot_ok || slot.op == Op::ILLEGAL)
                    {
                        // Try minimal manual decode of MOV_REG delay slot to keep common branches working
                        if ((slot_raw & 0xF00F) == 0x6003)
                        {
                            slot.op = Op::MOV_REG;
                            slot.dst.isImm = false; slot.dst.reg = (slot_raw >> 8) & 0xF;
                            slot.src1.isImm = false; slot.src1.reg = (slot_raw >> 4) & 0xF;
                        }
                        else
                        {
                            break; // cannot decode delay slot – stop block here
                        }
                    }
                    slot.pc  = slot_pc;
                    slot.raw = slot_raw;
                    blk.code.push_back(slot);
                    // blk.pcNext already set by branch (curr_pc +4) or dummy_slot_blk.pcNext as appropriate
                }

                // Advance curr_pc to blk.pcNext (straight-line case curr_pc+2)
                curr_pc_addr = blk.pcNext;
            }

            // END sentinel so executor stops at blk.pcNext.
            Instr end{};
            end.op = Op::END;
            end.pc = blk.pcNext;
            blk.code.push_back(end);
            return blk;
        }

        // Attempt fast-path decode first – if handled, emit block immediately
        bool fast_decoded_main_instr = FastDecode(raw, pc, ins, blk);
        DEBUG_LOG(SH4, "Emitter::CreateNew: PC=0x%08X, raw=0x%04X, FastDecode returned %d, blk.pcNext=0x%08X", pc, raw, fast_decoded_main_instr, blk.pcNext);
        if (fast_decoded_main_instr)
        {
            ins.pc = pc;
            ins.raw = raw;
            blk.code.push_back(ins);

            // If this instruction has a delay slot (pcNext == pc + 4), decode the slot too
            if (blk.pcNext == pc + 4)
            {
                uint32_t slot_pc = pc + 2;
                uint16_t slot_raw = mmu_IReadMem16(slot_pc);
                Instr slot{};
                // For decoding the slot, use a dummy block to prevent FastDecode from altering the main block's pcNext.
                // The main block's pcNext is determined by the primary branch instruction.
                Block dummy_slot_blk_for_decode;
                dummy_slot_blk_for_decode.pcStart = slot_pc;

                // Attempt FastDecode for the slot.
                // slot.op will be set by FastDecode (possibly to Op::ILLEGAL).
                // fast_decode_claims_handling will be true if FastDecode thinks it decoded it (even to ILLEGAL).
                bool fast_decode_claims_handling = FastDecode(slot_raw, slot_pc, slot, dummy_slot_blk_for_decode);
                INFO_LOG(SH4, "DS: slot_raw=0x%04X, FastDecode_handled=%d, FastDecode_op=%d (ILLEGAL=%d)", slot_raw, fast_decode_claims_handling, static_cast<int>(slot.op), static_cast<int>(Op::ILLEGAL));

                // We need to manually decode if FastDecode didn't handle it,
                // OR if it handled it by marking it ILLEGAL (giving manual decode a chance to do better).
                // Initialize slot_decoded to true ONLY if FastDecode provided a *valid* (non-ILLEGAL) opcode.
                bool slot_decoded = fast_decode_claims_handling && slot.op != Op::ILLEGAL;

                if (!slot_decoded) // If FastDecode didn't provide a valid op, try manual.
                {
                    INFO_LOG(SH4, "DS: Manual decode for slot_raw=0x%04X", slot_raw);
                    // Manual decode for the slot instruction if FastDecode failed
                    uint8_t slot_n_val = (slot_raw >> 8) & 0xF;
                    uint8_t slot_m_val = (slot_raw >> 4) & 0xF;

                    // RTS (0x000B)
                    if (slot_raw == 0x000B)
                    {
                        slot.op = Op::RTS;
                        slot_decoded = true;
                    }
                    // MOV Rm -> Rn  (0x6nm3)
                    else if ((slot_raw & 0xF00F) == 0x6003)
                    {
                        slot.op = Op::MOV_REG;
                        slot.dst.isImm = false;
                        slot.dst.reg = slot_n_val;
                        slot.src1.isImm = false;
                        slot.src1.reg = slot_m_val;
                        slot_decoded = true;
                        INFO_LOG(SH4, "DS: Manual decode matched MOV_REG (0x6nm3) for slot_raw=0x%04X", slot_raw);
                    }
                    // MOV #imm,Rn  (0xE000 | Rn<<8 | imm8)
                    else if ((slot_raw & 0xF000) == 0xE000)
                    {
                        slot.op = Op::MOV_IMM;
                        slot.dst.isImm = false;
                        slot.dst.reg = slot_n_val;
                        slot.src1.isImm = true;
                        slot.src1.imm = static_cast<int8_t>(slot_raw & 0xFF);
                        slot_decoded = true;
                    }
                    // ADD #imm,Rn  (0x7000 | Rn<<8 | imm8)
                    else if ((slot_raw & 0xF000) == 0x7000)
                    {
                        slot.op = Op::ADD_IMM;
                        slot.dst.isImm = false;
                        slot.dst.reg = slot_n_val;
                        slot.src1.isImm = true;
                        slot.src1.imm = static_cast<int8_t>(slot_raw & 0xFF);
                        slot_decoded = true;
                    }
                    // MOV.L @Rm+,Rn (0x6nm6) -> Op::LOAD32_POST
                    else if ((slot_raw & 0xF00F) == 0x6006)
                    {
                        slot.op = Op::LOAD32_POST;
                        slot.dst.isImm = false;
                        slot.dst.reg = slot_n_val; // Rn
                        slot.src1.isImm = false;
                        slot.src1.reg = slot_m_val; // Rm
                        slot_decoded = true;
                    }
                    // MOV.W @Rm+,R0 (0x6005, n must be 0) -> Op::LOAD16_POST
                    else if (slot_raw == 0x6005) // Check for specific R0 variant: MOV.W @Rm+,R0 (0x6m05 -> raw 6005 for R0,m) - n fixed to 0
                    {
                        slot.op = Op::LOAD16_POST;
                        slot.dst.isImm = false;
                        slot.dst.reg = 0; // R0
                        slot.src1.isImm = false;
                        slot.src1.reg = slot_m_val; // Rm
                        slot_decoded = true;
                    }
                    // MOV.B @Rm+,R0 (0x6004, n must be 0) -> Op::LOAD8_POST
                    else if (slot_raw == 0x6004) // Check for specific R0 variant: MOV.B @Rm+,R0 (0x6m04 -> raw 6004 for R0,m) - n fixed to 0
                    {
                        slot.op = Op::LOAD8_POST;
                        slot.dst.isImm = false;
                        slot.dst.reg = 0; // R0
                        slot.src1.isImm = false;
                        slot.src1.reg = slot_m_val; // Rm
                        slot_decoded = true;
                    }
                    // LDC Rm, <CR> (0x4mcE, where 'c' is control reg index, 'm' is source GPR Rm)
                    else if ((slot_raw & 0xF00F) == 0x400E) // Matches 0x4mcE pattern
                    {
                        slot.op = Op::LDC;
                        slot.src1.isImm = false;
                        slot.src1.reg = (slot_raw >> 8) & 0xF;    // Rm (source GPR)
                        uint8_t c_val = (slot_raw >> 4) & 0xF;    // c-field from opcode (control register category)

                        if (c_val == 5) // LDC Rm, Rn_BANK (opcode 0x4m5dE, d = bank reg index 0-7)
                        {
                            slot.extra = 8 + (slot_raw & 0x7); // R0_BANK -> 8, ..., R7_BANK -> 15
                        }
                        else
                        {
                            slot.extra = c_val;
                        }
                        slot_decoded = true;
                    }
                    // FRCHG (0xFBFD)
                    else if (slot_raw == 0xFBFD)
                    {
                        slot.op = Op::FRCHG;
                        slot_decoded = true;
                    }
                    // NOP (0x0009) is common in delay slots
                    else if (slot_raw == 0x0009)
                    {
                        slot.op = Op::NOP;
                        slot_decoded = true;
                    }
                    // STS.L PR,@-Rn (0x4n22)
                    else if ((slot_raw & 0xF0FF) == 0x4022)
                    {
                        slot.op = Op::STS_PR_L;
                        slot.dst.isImm = false;
                        slot.dst.reg = slot_n_val;
                        slot_decoded = true;
                    }
                    // LDS.L @Rn+,PR (0x4n6A)
                    else if ((slot_raw & 0xF0FF) == 0x406A)
                    {
                        slot.op = Op::LDS_PR_L;
                        slot.src1.isImm = false;
                        slot.src1.reg = slot_n_val;
                        slot_decoded = true;
                    }
                    // If no manual rule matched for the slot
                    if (!slot_decoded) {
                        slot.op = Op::ILLEGAL;
                    }
                }
                INFO_LOG(SH4, "DS: Pushing slot op %d for 0x%04X to block", static_cast<int>(slot.op), slot_raw);
                blk.code.push_back(slot);
            }

            // =============================
            //  Sequential decode extension
            // =============================
            uint32_t cur_pc = blk.pcNext;
            int    seq_count = 1; // already have one instr in block
            while (seq_count < 32 && blk.pcNext == cur_pc) // keep adding while linear flow
            {
                uint16_t next_raw = mmu_IReadMem16(cur_pc);
                // Do not extend the block past the first idle / NOP sequence marker.
                // Unit-tests typically place just a single instruction in memory and
                // leave the surrounding area zero-filled.  Executing those zeros
                // would make the interpreter continue far beyond the requested
                // operation, eventually triggering double-fault detection logic
                // and wiping the CPU state.  Bail-out as soon as we see NOP (0x0000)
                // or its SYNC/UNDEF variant (0x0009).
                if (next_raw == 0x0000 || next_raw == 0x0009)
                {
                    blk.pcNext = cur_pc + 2; // fall-through after current instr
                    break;
                }
                Instr next_ins{};
                Block dummy_blk; dummy_blk.pcStart = cur_pc;
                bool fast = FastDecode(next_raw, cur_pc, next_ins, dummy_blk);
                if (!fast || next_ins.op == Op::ILLEGAL) {
                    break; // stop on unknown
                }
                next_ins.pc  = cur_pc;
                next_ins.raw = next_raw;
                blk.code.push_back(next_ins);
                ++seq_count;

                // Branch?  pcNext differs from fall-through
                if (dummy_blk.pcNext != cur_pc + 2) {
                    blk.pcNext = dummy_blk.pcNext;
                    // handle delay slot likewise
                    if (blk.pcNext == cur_pc + 4) {
                        uint32_t slot_pc = cur_pc + 2;
                        uint16_t slot_raw = mmu_IReadMem16(slot_pc);
                        Instr slot_dec{};
                        Block dslot_blk; dslot_blk.pcStart = slot_pc;
                        FastDecode(slot_raw, slot_pc, slot_dec, dslot_blk);
                        slot_dec.pc  = slot_pc;
                        slot_dec.raw = slot_raw;
                        blk.code.push_back(slot_dec);
                    }
                    break;
                }

                // continue straight-line
                cur_pc += 2;
                blk.pcNext = cur_pc;
            }
            // Append single END terminator
            Instr end{}; end.op = Op::END; end.pc = blk.pcNext; end.raw = 0xFFFF;
            blk.code.push_back(end);

            // The block is complete, cache its signature and return it.
            g_block_sig_cache.emplace(sig, &blk);
            return blk;
        }
        else if (raw == 0x000B)
        {
            ins.op = Op::RTS;
            decoded = true;
            blk.pcNext = pc + 4; // includes delay slot
        }
        else if ((raw & 0xF00F) == 0x6003) // MOV Rm, Rn
        {
            INFO_LOG(SH4, "Emitter::CreateNew: Decoding MOV R%d, R%d (raw=0x%04X, pc=0x%08X)", m, n, raw, pc);
            fflush(stdout);
            ins.op = Op::MOV_REG;
            ins.dst.isImm = false;
            ins.dst.reg = n;
            ins.src1.isImm = false;
            ins.src1.reg = m;
        ins.src2.isImm = false;
        ins.src2.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MOV #imm,Rn  (0xE000 | Rn<<8 | imm8)
        else if ((raw & 0xF000) == 0xE000)
        {
            ins.op = Op::MOV_IMM;
            ins.dst.isImm = false;
            ins.dst.reg = n;
            ins.src1.isImm = true;
            ins.src1.imm = static_cast<int8_t>(raw & 0xFF);
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // ADD #imm,Rn  (0x7000 | Rn<<8 | imm8)
        else if ((raw & 0xF000) == 0x7000)
        {
            ins.op = Op::ADD_IMM;
            ins.dst.isImm = false;
            ins.dst.reg = n;
            ins.src1.isImm = true;
            ins.src1.imm = static_cast<int8_t>(raw & 0xFF);
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // BRA disp12  (0xA000 | disp)
        else if ((raw & 0xF000) == 0xA000)
        {
            uint32_t imm12 = raw & 0x0FFF;
            int32_t disp = static_cast<int32_t>(imm12 << 1);
            // Sign-extend 13-bit value (bit 12 is sign after shift)
            if (disp & 0x1000)
                disp |= ~0x1FFF;
            ins.op = Op::BRA;
            ins.extra = disp;
            decoded = true;
            blk.pcNext = pc + 4; // executes delay slot
        }
        // BSR disp12 (0xB000 | disp)
        else if ((raw & 0xF000) == 0xB000)
        {
            INFO_LOG(SH4, "Emitter::CreateNew: Manual BSR handler (0xB000) hit for PC=0x%08X, raw=0x%04X", pc, raw);
            ins.op = Op::BSR;
            ins.extra = vixl::SignExtend<int32_t>(raw & 0x0FFF, 12) * 2; // Displacement is 12-bit, sign-extended, and scaled by 2
            blk.pcNext = pc + 4; // BSR is a delayed branch
            INFO_LOG(SH4, "Emitter::CreateNew: Manual BSR handler (0xB000) hit for PC=0x%08X, raw=0x%04X. Displacement (ins.extra)=0x%08X, Target (calculated by executor)=0x%08X", pc, raw, ins.extra, pc + 4 + ins.extra);
            INFO_LOG(SH4, "Emitter::CreateNew: Manual BSR handler set blk.pcNext=0x%08X", blk.pcNext);
            decoded = true;
        }
        // BSRF Rn  (0x0n03)
        else if ((raw & 0xF0FF) == 0x0003)
        {
            ins.op = Op::BSRF;
            ins.src1.isImm = false;
            ins.src1.reg = n;
            decoded = true;
            blk.pcNext = pc + 4; // includes delay slot
        }
        // BRAF Rn  (0x0n23)
        else if ((raw & 0xF0FF) == 0x0023)
        {
            ins.op = Op::BRAF;
            ins.src1.isImm = false;
            ins.src1.reg = n;
            decoded = true;
            blk.pcNext = pc + 4; // delay slot
        }
        // STC SR, Rn (0000 nnnn 0000 0010 -> 0x0n02)
        else if ((raw & 0xF0FF) == 0x0002)
        {
            ins.op = Op::STC;
            ins.dst.isImm = false;
            ins.dst.reg = n;    // Rn
            ins.extra = 0;      // 0 for SR
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // STC GBR, Rn (0000 nnnn 0001 0010 -> 0x0n12)
        else if ((raw & 0xF0FF) == 0x0012)
        {
            ins.op = Op::STC;
            ins.dst.isImm = false;
            ins.dst.reg = n;    // Rn
            ins.extra = 1;      // 1 for GBR
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MOV.B/W/L Rm, @(R0, Rn)  -- 0x0*** forms (already handled below)
        else if ((raw & 0xF00F) == 0x0004 || (raw & 0xF00F) == 0x0005 || (raw & 0xF00F) == 0x0006)
        {
            uint8_t type = raw & 0xF;
            ins.src1.isImm = false;
            ins.src1.reg = m;
        ins.src2.isImm = false;
        ins.src2.reg = n; // Rm
            ins.src2.isImm = false;
            ins.src2.reg = n; // Rn
            // R0 is an implicit source for the executor
            if (type == 0x4) {
                ins.op = Op::STORE8_R0;
                INFO_LOG(SH4, "Emitter: Decoded STORE8_R0_REG R%d, @(R0,R%d) (0x%04X) at PC=0x%08X", m, n, raw, pc);
            } else if (type == 0x5) {
                ins.op = Op::STORE16_R0;
                INFO_LOG(SH4, "Emitter: Decoded STORE16_R0_REG R%d, @(R0,R%d) (0x%04X) at PC=0x%08X", m, n, raw, pc);
            } else { // type == 0x6
                ins.op = Op::STORE32_R0;
                INFO_LOG(SH4, "Emitter: Decoded STORE32_R0_REG R%d, @(R0,R%d) (0x%04X) at PC=0x%08X", m, n, raw, pc);
            }
            decoded = true;
            blk.pcNext = pc + 2;
        }
          // MOV.B/W/L Rm,@(R0,Rn)  — register-indexed form with leading ‘8’
        //  pattern: 1000 nnnn mmmm 0x?6  (type 0x4=byte, 0x5=word, 0x6=long)
        else if ((raw & 0xF000) == 0x8000 &&
                 ((raw & 0x000F) == 0x4 || (raw & 0x000F) == 0x5 || (raw & 0x000F) == 0x6))
        {
            uint8_t n    = (raw >> 8) & 0xF;   // base register Rn
            uint8_t m    = (raw >> 4) & 0xF;   // source register Rm
            uint8_t type =  raw        & 0xF;  // 0x4 / 0x5 / 0x6

            ins.src1.isImm = false;  ins.src1.reg = m;  // value
            ins.src2.isImm = false;  ins.src2.reg = n;  // base
            ins.extra      = 0;                        // R0-indexed (no disp)

            if (type == 0x4)      ins.op = Op::STORE8_Rm_R0RN;
            else if (type == 0x5) ins.op = Op::STORE16_Rm_R0RN;
            else                  ins.op = Op::STORE32_Rm_R0RN;

            INFO_LOG(SH4, "Emitter: Decoded op=%u R%d,@(R0,R%d) (%04X) PC=%08X",
                     static_cast<unsigned>(ins.op), m, n, raw, pc);

            decoded   = true;
            blk.pcNext = pc + 2;
        }
        // MOV.L Rm,@(disp,Rn) (0x1nmD)
        else if ((raw & 0xF000) == 0x1000)
        {
            ins.op = Op::STORE32;
            ins.src1.isImm = false;
            ins.src1.reg = m;
        ins.src2.isImm = false;
        ins.src2.reg = n; // Rm
            ins.src2.isImm = false;
            ins.src2.reg = n; // Rn
            ins.extra = (raw & 0xF) * 4; // displacement, scaled by 4
            INFO_LOG(SH4, "Emitter: Decoded STORE32 R%d, @(%d,R%d) (0x%04X) at PC=0x%08X", m, ins.extra, n, raw, pc);
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MOV.W Rm,@(disp,Rn) (0x9nmD)
        else if ((raw & 0xF000) == 0x9000)
        {
            ins.op = Op::STORE16;
            ins.src1.isImm = false;
            ins.src1.reg = m;
        ins.src2.isImm = false;
        ins.src2.reg = n; // Rm
            ins.src2.isImm = false;
            ins.src2.reg = n; // Rn
            ins.extra = (raw & 0xF) * 2; // displacement, scaled by 2
            INFO_LOG(SH4, "Emitter: Decoded STORE16 R%d, @(%d,R%d) (0x%04X) at PC=0x%08X", m, ins.extra, n, raw, pc);
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MULU.W Rm,Rn 0x2nmE - Unsigned 16-bit multiply, result in MACL
        else if ((raw & 0xF00F) == 0x200E)
        {
            ins.op = Op::MULU_W;
            ins.dst.isImm = false; ins.dst.reg = n; // use dst as Rn
            ins.src1.isImm = false; ins.src1.reg = m; // src1 as Rm
            decoded = true;
            blk.pcNext = pc + 2;
            INFO_LOG(SH4, "Emitter: Decoded MULU.W R%u,R%u (0x%04X) at PC=0x%08X",
                     m, n, raw, pc);
        }
        // MULS.W Rm,Rn 0x2nmF - Signed 16-bit multiply, result in MACL
        else if ((raw & 0xF00F) == 0x200F)
        {
            ins.op = Op::MULS_W;
            ins.dst.isImm = false; ins.dst.reg = n; // use dst as Rn
            ins.src1.isImm = false; ins.src1.reg = m; // src1 as Rm
            decoded = true;
            blk.pcNext = pc + 2;
            INFO_LOG(SH4, "Emitter: Decoded MULS.W R%u,R%u (0x%04X) at PC=0x%08X",
                     m, n, raw, pc);
        }
        // SUBX Rm,Rn 0x2nmE - Subtract with borrow
        else if ((raw & 0xF00F) == 0x200E && !decoded) // Add !decoded to avoid conflict with MULU.W
        {
            ins.op = Op::SUBX;
            ins.dst.isImm = false; ins.dst.reg = n; // use dst as Rn
            ins.src1.isImm = false; ins.src1.reg = m; // src1 as Rm
            decoded = true;
            blk.pcNext = pc + 2;
            INFO_LOG(SH4, "Emitter: Decoded SUBX R%u,R%u (0x%04X) at PC=0x%08X",
                     m, n, raw, pc);
        }
        // MAC.L @Rm+,@Rn+ - 32-bit multiply-accumulate with memory load and post-increment
        else if ((raw & 0xF00F) == 0x000F)
        {
            ins.op = Op::MAC_L;
            ins.dst.isImm = false; ins.dst.reg = n; // use dst as Rn
            ins.src1.isImm = false; ins.src1.reg = m; // src1 as Rm
            decoded = true;
            blk.pcNext = pc + 2;
            INFO_LOG(SH4, "Emitter: Decoded MAC.L @R%u+,@R%u+ (0x%04X) at PC=0x%08X",
                     m, n, raw, pc);
        }
        // MAC.W @Rm+,@Rn+ - 16-bit multiply-accumulate with memory load and post-increment
        else if ((raw & 0xF00F) == 0x400F)
        {
            ins.op = Op::MAC_W;
            ins.dst.isImm = false; ins.dst.reg = n; // use dst as Rn
            ins.src1.isImm = false; ins.src1.reg = m; // src1 as Rm
            decoded = true;
            blk.pcNext = pc + 2;
            INFO_LOG(SH4, "Emitter: Decoded MAC.W @R%u+,@R%u+ (0x%04X) at PC=0x%08X",
                     m, n, raw, pc);
        }
        // MOV.L Rm, @(disp, Rn) or MOV.L Rm, @Rn
        // Generic MOV.<size> Rm,@Rn and variants for type nibbles 0x0–0x6.
        // Do NOT catch 0x8–0xF, as those encode logical ops (TST/XOR/AND/OR, etc.).
        else if ((raw & 0xF000) == 0x2000 && (raw & 0x000F) <= 0x6)
        {
            INFO_LOG(SH4, "Emitter: Manual STORE32 path entered for raw=0x%04X, pc=0x%08X. m=R%d, n=R%d", raw, pc, m, n);
            uint8_t type_nibble = static_cast<uint8_t>(raw & 0xF);

            ins.src1.isImm = false;
            ins.src1.reg = (raw >> 4) & 0xF; // Rm (third nibble)
            ins.src2.isImm = false;
            ins.src2.reg = (raw >> 8) & 0xF; // Rn (second nibble)
            ins.extra = 0;    // For @Rn and @-Rn forms, displacement is 0 from opcode perspective.

            if (type_nibble == 0x0) { // MOV.B Rm, @Rn
                ins.op = Op::STORE8;
                INFO_LOG(SH4, "Emitter: Decoded STORE8 R%d, @R%d (0x%04X) at PC=0x%08X", (raw >> 4) & 0xF, (raw >> 8) & 0xF, raw, pc);
            } else if (type_nibble == 0x1) { // MOV.W Rm, @Rn
                ins.op = Op::STORE16;
                INFO_LOG(SH4, "Emitter: Decoded STORE16 R%d, @R%d (0x%04X) at PC=0x%08X", m, n, raw, pc);
            } else if (type_nibble == 0x2) { // MOV.L Rm, @Rn
                ins.op = Op::STORE32;
                INFO_LOG(SH4, "Emitter: Decoded STORE32 R%d, @R%d (0x%04X) at PC=0x%08X", m, n, raw, pc);
            } else if (type_nibble == 0x4) { // MOV.B Rm, @-Rn
                ins.op = Op::STORE8_PREDEC;
                INFO_LOG(SH4, "Emitter: Decoded STORE8_PREDEC R%d, @-R%d (0x%04X) at PC=0x%08X", m, n, raw, pc);
            } else if (type_nibble == 0x5) { // MOV.W Rm, @-Rn
                ins.op = Op::STORE16_PREDEC;
                INFO_LOG(SH4, "Emitter: Decoded STORE16_PREDEC R%d, @-R%d (0x%04X) at PC=0x%08X", m, n, raw, pc);
            } else if (type_nibble == 0x6) { // MOV.L Rm, @-Rn
                ins.op = Op::STORE32_PREDEC;
                INFO_LOG(SH4, "Emitter: Decoded STORE32_PREDEC R%d, @-R%d (0x%04X) at PC=0x%08X", m, n, raw, pc);
            } else if (type_nibble == 0xD) { // XTRCT Rm,Rn
                ins.op = Op::XTRCT;
                ins.dst.isImm = false; ins.dst.reg = n;
                ins.src1.isImm = false; ins.src1.reg = m;
        ins.src2.isImm = false;
        ins.src2.reg = n;
                INFO_LOG(SH4, "Emitter: Decoded XTRCT R%d (Rm=%d), R%d (Rn=%d) (0x%04X) at PC=0x%08X", m, m, n, n, raw, pc);
            } else {
                ins.op = Op::ILLEGAL;
                INFO_LOG(SH4, "Emitter: ILLEGAL/UNHANDLED 0x2xxx form (0x%04X), last nibble %X, at PC=0x%08X", raw, type_nibble, pc);
            }
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // STC VBR, Rn (0000 nnnn 0010 0010 -> 0x0n22)
        else if ((raw & 0xF0FF) == 0x0022)
        {
            ins.op = Op::STC;
            ins.dst.isImm = false;
            ins.dst.reg = n;    // Rn
            ins.extra = 2;      // 2 for VBR
            decoded = true;
            blk.pcNext = pc + 2;
            INFO_LOG(SH4, "Emitter: Decoded STC VBR, R%d (0x%04X) at PC=0x%08X", n, raw, pc);
        }
        // STC SSR, Rn (0000 nnnn 0011 0010 -> 0x0n32)
        else if ((raw & 0xF0FF) == 0x0032)
        {
            ins.op = Op::STC;
            ins.dst.isImm = false;
            ins.dst.reg = n;    // Rn
            ins.extra = 3;      // 3 for SSR
            decoded = true;
            blk.pcNext = pc + 2;
            INFO_LOG(SH4, "Emitter: Decoded STC SSR, R%d (0x%04X) at PC=0x%08X", n, raw, pc);
        }
        // STC SPC, Rn (0000 nnnn 0100 0010 -> 0x0n42)
        else if ((raw & 0xF0FF) == 0x0042)
        {
            ins.op = Op::STC;
            ins.dst.isImm = false;
            ins.dst.reg = n;    // Rn
            ins.extra = 4;      // 4 for SPC
            decoded = true;
            blk.pcNext = pc + 2;
            INFO_LOG(SH4, "Emitter: Decoded STC SPC, R%d (0x%04X) at PC=0x%08X", n, raw, pc);
        }
        // STC DBR, Rn (0000 nnnn 1111 0010 -> 0x0nF2)
        // This must be before STC Rj_BANK, Rn to correctly identify DBR vs R7_BANK (both can have 0xF in middle nibble)
        else if ((raw & 0xF0FF) == 0x00F2)
        {
            ins.op = Op::STC;
            ins.dst.isImm = false;
            ins.dst.reg = n;    // Rn
            ins.extra = 7;      // Use 7 for DBR (consistent with LDC and unique for STC to Rn)
            decoded = true;
            blk.pcNext = pc + 2;
            INFO_LOG(SH4, "Emitter: Decoded STC DBR, R%d (0x%04X) at PC=0x%08X", n, raw, pc);
        }
        // STC Rj_BANK, Rn (0000 nnnn jjjj 1010 -> 0x0njA, j=bank 0-7)
        else if ((raw & 0xF00F) == 0x000A) // Matches 0x0njA pattern
        {
            uint8_t j_bank_field = (raw >> 4) & 0xF;
            // Banked registers are encoded with j=0x8..0xF (R0_BANK..R7_BANK)
            if (j_bank_field >= 0x8 && j_bank_field <= 0xF) {
                uint8_t bank_index = j_bank_field - 0x8; // 0..7
                ins.op = Op::STC;
                ins.dst.isImm = false;
                ins.dst.reg = n; // Rn
                ins.extra = 8 + bank_index; // 8..15 maps to R0_BANK..R7_BANK
                decoded = true;
                blk.pcNext = pc + 2;
                INFO_LOG(SH4, "Emitter: Decoded STC R%d_BANK, R%d (0x%04X) at PC=0x%08X", j_bank_field, n, raw, pc);
            }
        }
        // STS.L PR,@-Rn (0x4n22)
        else if ((raw & 0xF0FF) == 0x4022)
        {
            ins.op = Op::STS_PR_L;
            ins.dst.isImm = false;
            ins.dst.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // LDS.L @Rn+,PR (0x4n6A)
        else if ((raw & 0xF0FF) == 0x406A)
        {
            ins.op = Op::LDS_PR_L;
            ins.src1.isImm = false;
            ins.src1.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // DT Rn (0x4n11)
        else if ((raw & 0xF0FF) == 0x4011)
        {
            ins.op = Op::DT;
            ins.dst.isImm = false;
            ins.dst.reg = n; // Rn is the register to decrement and test
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // SHLL2/8/16 Rn  (0x4n08,0x4n18,0x4n28)
        else if ((raw & 0xF00F) == 0x4008)
        {
            uint8_t sub = (raw >> 4) & 0xF; // bits 7-4 determine variant
            uint8_t shift = 0;
            switch (sub)
            {
            case 0x0: shift = 2; break;   // 0x4n08
            case 0x1: shift = 8; break;   // 0x4n18
            case 0x2: shift = 16; break;  // 0x4n28
            default: shift = 1; break; // fallback
            }
            ins.op = Op::SHL;
            ins.dst.isImm = false;
            ins.dst.reg = n;
            ins.extra = shift;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MOV.B @Rm,Rn  (0x6nm0)   sign-extended byte load
        else if ((raw & 0xF00F) == 0x6000)
        {
            ins.op = Op::LOAD8;
            ins.dst.isImm = false;
            ins.dst.reg = n;
            ins.src1.isImm = false;
            ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MOV.L @Rm,Rn (0x6nm2)
        else if ((raw & 0xF00F) == 0x6002 && m != 0)
        {
            ins.op = Op::LOAD32;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.B @Rm+,Rn (0x6nm4)
        else if ((raw & 0xF00F) == 0x6004)
        {
            ins.op = Op::LOAD8_POST;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MOV.W @Rm+,Rn (0x6nm5)
        else if ((raw & 0xF00F) == 0x6005)
        {
            ins.op = Op::LOAD16_POST;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.L @Rm+,Rn (0x6nm6)
        else if ((raw & 0xF00F) == 0x6006)
        {
            ins.op = Op::LOAD32_POST;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
            INFO_LOG(SH4, "Emitter::CreateNew: Manually decoded MOV.L @R%d+,R%d (0x%04X) at PC=0x%08X", m, n, raw, pc);
        }
        // DT Rn (0x4n11)
        else if ((raw & 0xF0FF) == 0x4011)
        {
            ins.op = Op::DT;
            ins.dst = {false, n}; // Rn is in bits 11-8, already extracted as 'n'
            ins.dst.type = RegType::GPR; // Explicitly GPR
            blk.pcNext = pc + 2;   // DT is not a branch
            decoded = true;
            INFO_LOG(SH4, "Emitter::CreateNew: Manually decoded DT R%d (0x%04X) at PC=0x%08X", n, raw, pc);
        }
        // NEG Rm -> Rn  (0x6nmB)
        else if ((raw & 0xF00F) == 0x600B)
        {
            ins.op = Op::NEG;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // EXTU.B Rm -> Rn  (0x6nmC)
        else if ((raw & 0xF00F) == 0x600C)
        {
            ins.op = Op::EXTU_B;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // EXTS.B Rm -> Rn  (0x6nmD)
        else if ((raw & 0xF00F) == 0x600D)
        {
            ins.op = Op::EXTS_B;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // EXTU.W Rm -> Rn  (0x6nmE)
        else if ((raw & 0xF00F) == 0x600E)
        {
            ins.op = Op::EXTU_W;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // BF/BF_S/BT/BT_S conditional branches (0x89/8B/8D/8F)
        else if ((raw & 0xFF00) == 0x8B00) // BF disp8, no delay slot
        {
            int8_t disp = raw & 0xFF;
            int32_t d = static_cast<int32_t>(disp) << 1;
            ins.op = Op::BF;
            ins.extra = d;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        else if ((raw & 0xFF00) == 0x8F00) // BF/S with delay slot
        {
            int8_t disp = raw & 0xFF;
            int32_t d = static_cast<int32_t>(disp) << 1;
            ins.op = Op::BF_S;
            ins.extra = d;
            decoded = true;
            blk.pcNext = pc + 4; // executes delay slot
        }
        else if ((raw & 0xFF00) == 0x8900) // BT disp8
        {
            int8_t disp = raw & 0xFF;
            int32_t d = static_cast<int32_t>(disp) << 1;
            ins.op = Op::BT;
            ins.extra = d;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        else if ((raw & 0xFF00) == 0x8D00) // BT/S with delay
        {
            int8_t disp = raw & 0xFF;
            int32_t d = static_cast<int32_t>(disp) << 1;
            ins.op = Op::BT_S;
            ins.extra = d;
            decoded = true;
            blk.pcNext = pc + 4;
        }

        // SHLD Rm,Rn  (0x4nm9)
        else if ((raw & 0xF00F) == 0x4009)
        {
            ins.op = Op::SHLD;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // EXTS.W Rm -> Rn  (0x6nmF)
        else if ((raw & 0xF00F) == 0x600F)
        {
            ins.op = Op::EXTS_W;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.B Rm,@Rn  (0x2nm0)
        else if ((raw & 0xF00F) == 0x2000)
        {
            ins.op = Op::STORE8;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.L Rm,@Rn  (0x2nm2)
        else if ((raw & 0xF00F) == 0x2002)
        {
            ins.op = Op::STORE32;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.B Rm,@Rn+ (0x2nm4)
        else if ((raw & 0xF00F) == 0x2004)
        {
            ins.op = Op::STORE8_POST;
            ins.dst.isImm = false; ins.dst.reg = n; // Rn is destination address register
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n; // Rm supplies value
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.W Rm,@Rn+ (0x2nm5)
        else if ((raw & 0xF00F) == 0x2005)
        {
            ins.op = Op::STORE16_POST;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.L Rm,@Rn+ (0x2nm6)
        else if ((raw & 0xF00F) == 0x2006)
        {
            ins.op = Op::STORE32_POST;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // CMP/EQ Rm,Rn  (0x3nm0)
        else if ((raw & 0xF00F) == 0x3000)
        {
            ins.op = Op::CMP_EQ;
            ins.dst.isImm = false; ins.dst.reg = n; // Rn
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n; // Rm
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // CMP/HI Rm,Rn (0x3nm6)
        else if ((raw & 0xF00F) == 0x3006)
        {
            ins.op = Op::CMP_HI;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // CMP/HS Rm,Rn (0x3nm2)
        else if ((raw & 0xF00F) == 0x3002)
        {
            ins.op = Op::CMP_HS;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // CMP/GE Rm,Rn (0x3nm3)
        else if ((raw & 0xF00F) == 0x3003)
        {
            ins.op = Op::CMP_GE;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // CMP/GT Rm,Rn (0x3nm7)
        else if ((raw & 0xF00F) == 0x3007)
        {
            ins.op = Op::CMP_GT;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // SUB Rm,Rn (0x3nm8)
        else if ((raw & 0xF00F) == 0x3008)
        {
            ins.op = Op::SUB;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // SUBV Rm,Rn (0x3nmB)
        else if ((raw & 0xF00F) == 0x300B)
        {
            ins.op = Op::SUBV;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // DIV1 Rm,Rn (0x3nm4)
        else if ((raw & 0xF00F) == 0x3004)
        {
            ins.op = Op::DIV1;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            INFO_LOG(SH4, "FastDecode: Decoded DIV1 R%u,R%u (0x%04X) at PC=%08X",
                     ins.src1.reg, ins.dst.reg, raw, pc);
            decoded = true; blk.pcNext = pc + 2;
        }
        // DMULS.L Rm,Rn (0x3nmD) - Signed 32x32->64 multiply
        else if ((raw & 0xF00F) == 0x300D)
        {
            ins.op = Op::DMULS_L;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            INFO_LOG(SH4, "FastDecode: Decoded DMULS.L R%u,R%u (0x%04X) at PC=%08X",
                     ins.src1.reg, ins.dst.reg, raw, pc);
            decoded = true; blk.pcNext = pc + 2;
        }
        // DMULU.L Rm,Rn (0x3nm5) - Unsigned 32x32->64 multiply
        else if ((raw & 0xF00F) == 0x3005)
        {
            ins.op = Op::DMULU_L;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            INFO_LOG(SH4, "FastDecode: Decoded DMULU.L R%u,R%u (0x%04X) at PC=%08X",
                     ins.src1.reg, ins.dst.reg, raw, pc);
            decoded = true; blk.pcNext = pc + 2;
        }

        // ADD Rm, Rn (0x3nmC) - Integer addition
        else if ((raw & 0xF00F) == 0x300C)
        {
            ins.op = Op::ADD;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            decoded = true; blk.pcNext = pc + 2;
        }
        // CMP/PL Rn (0x4n05)
        else if ((raw & 0xF0FF) == 0x4005)
        {
            ins.op = Op::CMP_PL;
            ins.src1.isImm = false; ins.src1.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // TST #imm8,R0  (0xC8??)
        else if ((raw & 0xFF00) == 0xC800)
        {
            ins.op = Op::TST_IMM;
            ins.src1.isImm = true; ins.src1.imm = raw & 0xFF;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MOVT Rn (0x0n29)
        else if ((raw & 0x00FF) == 0x0029)
        {
            ins.op = Op::MOVT;
            ins.dst.isImm = false; ins.dst.reg = (raw >> 8) & 0xF;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // RTE (return from exception, has delay slot) 0x002B

        // RTE (return from exception, has delay slot) 0x002B
        else if (raw == 0x002B)
        {
            ins.op = Op::RTE;
            decoded = true;
            blk.pcNext = pc + 4; // one delay slot
        }
        // XTRCT Rm,Rn (0x2nmD)
        else if ((raw & 0xF00F) == 0x200D)
        {
            uint8_t n = (raw >> 8) & 0xF;
            uint8_t m = (raw >> 4) & 0xF;
            ins.op = Op::XTRCT;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MOV.W @(disp,PC),Rn  (0x9000 | Rn<<8 | disp8)
        else if ((raw & 0xF000) == 0x9000)
        {
            uint8_t disp = raw & 0xFF;
            // Use LOAD16_PC to match LOAD32_PC approach
            ins.op = Op::LOAD16_PC;
            ins.dst.isImm = false;
            ins.dst.reg = n;
            ins.extra = disp; // keep raw disp8 for executor to use
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // LDC.L @Rm+, <CR> (0x4mc7, where 'c' is control reg index, 'm' is GPR Rm for address)
        // SR(c=0), GBR(c=1), VBR(c=2), SSR(c=3), SPC(c=4),
        // Rn_BANK(c=5, actual bank reg in bits 3-0 of opcode),
        // SGR(c=6), DBR(c=7)
        else if ((raw & 0xF00F) == 0x4007) // Matches 0x4mc7 pattern
        {
            ins.op = Op::LDC_L;
            ins.src1.isImm = false;
            ins.src1.reg = (raw >> 8) & 0xF;    // Rm (source GPR for address, post-incremented)
            uint8_t c_val = (raw >> 4) & 0xF;    // c-field from opcode (control register category)

            if (c_val == 5) // LDC.L @Rm+, Rn_BANK (opcode 0x4m5d7, d = bank reg index 0-7)
            {
                ins.extra = 8 + (raw & 0x7); // R0_BANK -> 8, ..., R7_BANK -> 15
            }
            else
            {
                ins.extra = c_val;
            }
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MOV.L @(disp,PC),Rn  (0xD000 | Rn<<8 | disp8)
        else if ((raw & 0xF000) == 0xD000)
        {
            uint8_t disp = raw & 0xFF;
            ins.op = Op::LOAD32_PC;
            ins.dst.isImm = false;
            ins.dst.reg = n;
            ins.extra = disp; // keep raw disp8 for executor to use
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // JSR @Rn  (0x4n0B) – operand register is 'n' (bits 11-8) and bits 7-4 must be 0000
        else if ((raw & 0xF0FF) == 0x400B)
        {
            ins.op = Op::JSR;
            ins.src1.isImm = false;
            ins.src1.reg = n;
            decoded = true;
            blk.pcNext = pc + 4;
        }
        // JMP @Rn  (0x4n2B) – operand register is 'n'
        else if ((raw & 0xF0FF) == 0x402B)
        {
            ins.op = Op::JMP;
            ins.src1.isImm = false;
            ins.src1.reg = n;
            decoded = true;
            blk.pcNext = pc + 4;
        }
        // RTS (0x000B)
        else if (raw == 0x000B)
        {
            ins.op = Op::RTS;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // SWAP.B Rm,Rn 0x6nm8
        else if ((raw & 0xF00F) == 0x6008)
        {
            ins.op = Op::SWAP_B;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // SWAP.W Rm,Rn 0x6nm9
        else if ((raw & 0xF00F) == 0x6009)
        {
            ins.op = Op::SWAP_W;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // AND Rm,Rn 0x2nm9
        else if ((raw & 0xF00F) == 0x2009)
        {
            ins.op = Op::AND_REG;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // TST Rm,Rn 0x2nm8
        else if ((raw & 0xF00F) == 0x2008)
        {
            ins.op = Op::TST_REG;
            ins.dst.isImm = false; ins.dst.reg = n; // Rn is first operand (same as AND)
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n; // Rm
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // XOR Rm,Rn 0x2nmA
        else if ((raw & 0xF00F) == 0x200A)
        {
            ins.op = Op::XOR_REG;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // OR Rm,Rn 0x2nmB
        else if ((raw & 0xF00F) == 0x200B)
        {
            ins.op = Op::OR_REG;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // NOT Rm,Rn 0x6nm7
        else if ((raw & 0xF00F) == 0x6007)
        {
            ins.op = Op::NOT_OP;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // DT Rn 0x4010
        else if ((raw & 0xF0FF) == 0x4010)
        {
            ins.op = Op::DT;
            ins.dst.isImm = false; ins.dst.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // SHLL Rn (shift left 1) 0x4000
        else if ((raw & 0xF0FF) == 0x4000)
        {
            ins.op = Op::SHL1;
            ins.dst.isImm = false; ins.dst.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // SHLR Rn 0x4001
        else if ((raw & 0xF0FF) == 0x4001)
        {
            ins.op = Op::SHR1;
            ins.dst.isImm = false; ins.dst.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // SHAL Rn 0x4020 (same as SHL1)
        else if ((raw & 0xF0FF) == 0x4020)
        {
            ins.op = Op::SHL1;
            ins.dst.isImm = false; ins.dst.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // SHAR Rn 0x4021
        else if ((raw & 0xF0FF) == 0x4021)
        {
            ins.op = Op::SAR1;
            ins.dst.isImm = false; ins.dst.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // SHLD Rm,Rn 0x4nmD (shift left double, uses Rm low 16 bits)
        else if ((raw & 0xF00F) == 0x400D)
        {
            ins.op = Op::SHLD;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // ROTL Rn 0x4004
        else if ((raw & 0xF0FF) == 0x4004)
        {
            ins.op = Op::SHL; // reuse SHL with extra=1 but wrap-around later in exec
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.extra = 1 | 0x80; // flag 0x80 indicates rotate
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // ROTR Rn 0x4005
        else if ((raw & 0xF0FF) == 0x4005)
        {
            ins.op = Op::SHR_OP; // treat as right rotate 1 using flag
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.extra = 1 | 0x80;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // AND #imm8,R0 0xC9??
        else if ((raw & 0xFF00) == 0xC900)
        {
            ins.op = Op::AND_IMM;
            ins.dst.isImm = false; ins.dst.reg = 0;
            ins.src1.isImm = true; ins.src1.imm = raw & 0xFF;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // XOR #imm8,R0 0xCA??
        else if ((raw & 0xFF00) == 0xCA00)
        {
            ins.op = Op::XOR_IMM;
            ins.dst.isImm = false; ins.dst.reg = 0;
            ins.src1.isImm = true; ins.src1.imm = raw & 0xFF;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // OR #imm8,R0 0xCB??
        else if ((raw & 0xFF00) == 0xCB00)
        {
            ins.op = Op::OR_IMM;
            ins.dst.isImm = false; ins.dst.reg = 0;
            ins.src1.isImm = true; ins.src1.imm = raw & 0xFF;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MOV.B R0,@(disp,GBR) 0xC0??
        else if ((raw & 0xFF00) == 0xC000)
        {
            uint8_t disp = raw & 0xFF;
            ins.op = Op::STORE8_GBR;
            ins.src1.isImm = false; ins.src1.reg = 0; // R0 value
            ins.extra = disp; // byte offset
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.W R0,@(disp,GBR) 0xC1??
        else if ((raw & 0xFF00) == 0xC100)
        {
            uint8_t disp = raw & 0xFF;
            ins.op = Op::STORE16_GBR;
            ins.src1.isImm = false; ins.src1.reg = 0;
            ins.extra = disp << 1;
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.L R0,@(disp,GBR) 0xC2??
        else if ((raw & 0xFF00) == 0xC200)
        {
            uint8_t disp = raw & 0xFF;
            ins.op = Op::STORE32_GBR;
            ins.src1.isImm = false; ins.src1.reg = 0;
            ins.extra = disp << 2;
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.B @(disp,GBR),R0 0xC4??
        else if ((raw & 0xFF00) == 0xC400)
        {
            uint8_t disp = raw & 0xFF;
            ins.op = Op::LOAD8_GBR;
            ins.dst.isImm = false; ins.dst.reg = 0;
            ins.extra = disp;
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.W @(disp,GBR),R0 0xC5??
        else if ((raw & 0xFF00) == 0xC500)
        {
            uint8_t disp = raw & 0xFF;
            ins.op = Op::LOAD16_GBR;
            ins.dst.isImm = false; ins.dst.reg = 0;
            ins.extra = disp << 1;
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.L @(disp,GBR),R0 0xC6??
        else if ((raw & 0xFF00) == 0xC600)
        {
            uint8_t disp = raw & 0xFF;
            ins.op = Op::LOAD32_GBR;
            ins.dst.isImm = false; ins.dst.reg = 0;
            ins.extra = disp << 2;
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOVA @(disp,PC),R0 0xC7??
        else if ((raw & 0xFF00) == 0xC700)
        {
            uint8_t disp = raw & 0xFF;
            uint32_t effective_address = (pc & ~3u) + 4u + (static_cast<uint32_t>(disp) << 2);
            ins.op = Op::MOV_IMM;
            ins.dst.isImm = false;
            ins.dst.reg = 0;
            ins.src1.isImm = true;
            ins.src1.imm = effective_address;
            DEBUG_LOG(SH4, "Emitter: Decoded MOVA_PC @(disp=%02X,PC=%08X) -> MOV R0, #%08X (0x%04X)", disp, pc, effective_address, raw);
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.L @(disp,PC),Rn (0xDnnn) -- This is a PC-relative literal load.
        // The previous MOV.L @(disp,Rm),Rn handler was incorrectly matching this.
        else if ((raw & 0xF000) == 0xD000)
        {
            uint8_t disp8 = raw & 0xFF;
            ins.op = Op::LOAD32_PC;
            ins.dst.isImm = false;
            ins.dst.reg = n;
            ins.extra = disp8; // Pass raw 8-bit displacement to executor
            DEBUG_LOG(SH4, "Emitter: Decoded LOAD32_PC @(disp=%02X,PC=%08X) -> R%d (0x%04X)", disp8, pc, n, raw);
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MOV.L @(disp,Rm),Rn / @(disp,PC),Rn -- 0x5nmd
        else if ((raw & 0xF000) == 0x5000)
        {
            // Check if this is specifically MOV.L @(disp,Rm),Rn (0x5nm2)
            // The pattern is 0x5nm2 where n=register number, m=register number, 2=fixed
            if ((raw & 0xF) == 0x2)
            {
                // This is the specific MOV.L @(disp,Rm),Rn form
                uint8_t disp4 = (raw >> 0) & 0xF;
                ins.op = Op::LOAD32;
                ins.dst.isImm = false; ins.dst.reg = n;
                ins.src1.isImm = false; ins.src1.reg = m;
                ins.src2.isImm = false; ins.src2.reg = n;
                ins.pc = pc;
                ins.raw = raw;
                ins.extra = disp4 * 4; // disp is lower 4 bits, scaled by 4
                INFO_LOG(SH4, "Emitter: Decoded MOV.L @(0x%X,R%d),R%d (0x%04X) at PC=0x%08X", ins.extra, m, n, raw, pc);
            }
            else if (((raw >> 4) & 0xF) == 0) // m == 0, treat as PC-relative based on user feedback
            {
                // Per user instruction, use special displacement for this case.
                uint32_t disp = (raw & 0x0FFF) >> 2;
                ins.op = Op::LOAD32_PC;
                ins.dst.isImm = false;
                ins.dst.reg = n;
                ins.extra = disp;
                INFO_LOG(SH4, "Emitter: Decoded LOAD32_PC (5nmd special) @(disp=%03X,PC=%08X) -> R%d (0x%04X)", disp, pc, n, raw);
            }
            else
            {
                // Handle other 0x5000 patterns (if any)
                uint8_t disp4 = raw & 0xF;
                ins.op = Op::LOAD32;
                ins.dst.isImm = false;
                ins.dst.reg = n;
                ins.src1.isImm = false;
                ins.src1.reg = m;
                ins.src2.isImm = false;
                ins.src2.reg = n;
                ins.extra = disp4 * 4;
                INFO_LOG(SH4, "Emitter: Decoded generic LOAD32 @(0x%X,R%d),R%d (0x%04X) at PC=0x%08X", ins.extra, m, n, raw, pc);
            }
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MOV.B R0,@(disp,Rn) 0x8n0d (d=disp4)
        else if ((raw & 0xFF00) == 0x8000)
        {
            uint8_t disp4 = static_cast<uint8_t>(raw & 0xF);
            ins.op = Op::STORE8_R0;
            ins.dst.isImm = false; ins.dst.reg = (raw >> 4) & 0xF; // Rn
            ins.src1.isImm = false; ins.src1.reg = 0;
            ins.src2.isImm = false; ins.src2.reg = ins.dst.reg;
            ins.extra = disp4; // byte displacement
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MOV.W R0,@(disp,Rn) 0x8n1d
        else if ((raw & 0xFF00) == 0x8100)
        {
            uint8_t disp4 = static_cast<uint8_t>(raw & 0xF); // 4-bit displacement
            ins.op = Op::STORE16_R0;
            ins.dst.isImm = false; ins.dst.reg = (raw >> 4) & 0xF; // Rn
            ins.src1.isImm = false; ins.src1.reg = 0; // value in R0
            ins.src2.isImm = false; ins.src2.reg = ins.dst.reg;     // base register
            ins.extra = disp4 * 2;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MOV.L R0,@(disp,Rn) 0x8n2d
        else if ((raw & 0xFF00) == 0x8200)
        {
            uint8_t disp4 = static_cast<uint8_t>(raw & 0xF);
            ins.op = Op::STORE32_R0;
            ins.dst.isImm = false; ins.dst.reg = (raw >> 4) & 0xF;
            ins.src1.isImm = false; ins.src1.reg = 0;
            ins.src2.isImm = false; ins.src2.reg = ins.dst.reg;
            ins.extra = disp4 * 4;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MOV.B @(disp,Rm),Rn 0x8nmd (disp=low4)
        else if ((raw & 0xF000) == 0x8000)
        {
            uint8_t disp4 = raw & 0xF;
            ins.op = Op::LOAD8;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            ins.extra = disp4; // byte displacement
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MOV.W @(disp,Rm),Rn 0x9nmd (disp=low4*2)
        else if ((raw & 0xF000) == 0x9000)
        {
            uint8_t disp4 = raw & 0xF;
            ins.op = Op::LOAD16;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            ins.extra = disp4 * 2;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // JSR @(disp,PC) case was erroneously matched by 0xA000 earlier. The SH-4 ISA does NOT have such an instruction;
        // JSR is register-indirect (pattern 0x4nmB). Therefore the previous block decoding 0xA000 as JSR has been removed.
        // SHLR2/8/16 Rn : 0x4n09,0x4n19,0x4n29
        else if ((raw & 0xF00F) == 0x4009)
        {
            uint8_t idx = (raw >> 4) & 0xF; // middle nibble determines amount
            int shift = (idx == 0) ? 2 : (idx == 1 ? 8 : 16);
            ins.op = Op::SHR_OP;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.extra = shift;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // SAR2/8/16 Rn : 0x4n0A, 0x4n1A, 0x4n2A (arithmetic right shift)
        else if ((raw & 0xF00F) == 0x400A)
        {
            uint8_t idx = (raw >> 4) & 0xF;
            int shift = (idx == 0) ? 2 : (idx == 1 ? 8 : 16);
            ins.op = Op::SAR_OP;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.extra = shift;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // NOP (all-zero word)
        else if (raw == 0x0000)
        {
            ins.op = Op::NOP;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // NOP (No operation)
        else if (raw == 0x0009)
        {
            ins.op = Op::NOP;
            decoded = true;
            blk.pcNext = pc + 2;
        }

        // MOV.B @(disp,Rm),R0 0x0nmd (disp = low4)  — allow n=0 too (except 0x0000 and 0x0009)
        else if ((raw & 0xF000) == 0x0000 && (raw & 0x000F) <= 0x0B)
        {
            if (raw == 0x0009 || raw == 0x0000)
            {
                ins.op = Op::NOP;
                decoded = true;
                blk.pcNext = pc + 2;
            }
            else
            {
                uint8_t disp4 = raw & 0xF;
                uint8_t n_reg = (raw >> 8) & 0xF;
                uint8_t m_reg = (raw >> 4) & 0xF;
                ins.op = Op::STORE8;
                ins.dst.isImm = false; ins.dst.reg = n_reg; // base
                ins.src1.isImm = false; ins.src1.reg = m_reg; // value
                ins.extra = disp4; // byte offset
                decoded = true; blk.pcNext = pc + 2;
            }
        }
        // MOV.L Rm,@(disp,Rn) 0x1nmd (disp = low4 * 4)
         // Handles BIOS pattern like 0x18E0 (MOV.L R8,@(0xE*4,R0))
         else if ((raw & 0xF000) == 0x1000)
         {
             uint8_t disp4 = raw & 0xF;
             ins.op = Op::STORE32;
             ins.dst.isImm = false; ins.dst.reg = n;    // base register Rn
             ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;  // value register Rm
             ins.extra = disp4 * 4;                     // long = 4 bytes
             decoded = true;
             blk.pcNext = pc + 2;
         }
        // MOV.L Rm,@(disp,Rn) 0x2nmd (same as 0x1nmd on some opcode maps) retain for compatibility
         else if ((raw & 0xF000) == 0x2000)
         {
             uint8_t disp4 = raw & 0xF;
             ins.op = Op::STORE32;
             ins.dst.isImm = false; ins.dst.reg = n;
             ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
             ins.extra = disp4 * 4;
             decoded = true;
             blk.pcNext = pc + 2;
             INFO_LOG(SH4, "Emitter::CreateNew: Decoded STORE32 R%d -> @(0x%X,R%d) (0x%04X) at PC=0x%08X", m, disp4*4, n, raw, pc);
         }
        // MOV.W Rm,@(disp,Rn) 0x3nm5 (disp = low4 * 2)
         else if ((raw & 0xF00F) == 0x3005)
         {
             uint8_t disp4 = raw & 0xF;
             ins.op = Op::STORE16;
             ins.dst.isImm = false; ins.dst.reg = n;
             ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
             ins.extra = disp4 * 2;
             decoded = true; blk.pcNext = pc + 2;
         }
         // MOV.L Rm,@(disp,Rn) 0x4nmd (some CPUs) retained below for safety
        // (original code)
        else if ((raw & 0xF000) == 0x4000 && (raw & 0x0F00) != 0x0000) // legacy path, keep for compatibility
        {
            uint8_t disp4 = raw & 0xF;
            ins.op = Op::STORE32;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            ins.extra = disp4 * 4;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // LDC Rm, <CR> (0x4mcE, where 'c' is control reg index, 'm' is source GPR Rm)
        // SR(c=0), GBR(c=1), VBR(c=2), SSR(c=3), SPC(c=4),
        // Rn_BANK(c=5, actual bank reg in bits 3-0 of opcode),
        // SGR(c=6), DBR(c=7)
        else if ((raw & 0xF00F) == 0x400E) // Matches 0x4mcE pattern
        {
            ins.op = Op::LDC;
            ins.src1.isImm = false;
            ins.src1.reg = (raw >> 8) & 0xF;    // Rm (source GPR)
            uint8_t c_val = (raw >> 4) & 0xF;    // c-field from opcode (control register category)

            if (c_val == 5) // LDC Rm, Rn_BANK (opcode 0x4m5dE, d = bank reg index 0-7)
            {
                // For Rn_BANK, the specific bank register (0-7) is in raw bits 3-0.
                // Map this to extra = 8 + (bank_reg_idx from bits 3-0 of opcode)
                ins.extra = 8 + (raw & 0x7); // R0_BANK -> 8, ..., R7_BANK -> 15
            }
            else
            {
                // For SR, GBR, VBR, SSR, SPC, SGR, DBR, c_val is directly used.
                // c_val will be 0, 1, 2, 3, 4, 6, or 7.
                ins.extra = c_val;
            }
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MOV.B Rm,@Rn 0x0nm3
        else if ((raw & 0xF00F) == 0x0003)
        {
            ins.op = Op::STORE8;
            ins.dst.isImm = false; ins.dst.reg = n; // Rn base
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n; // value in Rm
            ins.extra = 0;
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.B Rm,@(R0,Rn) 0x0nm4
        else if ((raw & 0xF00F) == 0x0004)
        {
            ins.op = Op::STORE8_R0;
            ins.dst.isImm = false; ins.dst.reg = n; // Rn base
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n; // value in Rm
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.W Rm,@(R0,Rn) 0x0nm5
        else if ((raw & 0xF00F) == 0x0005)
        {
            ins.op = Op::STORE16_R0;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
        ins.src2.isImm = false;
        ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.L Rm,@(R0,Rn) 0x0nm6
        else if ((raw & 0xF00F) == 0x0006)
        {
            ins.op = Op::STORE32_R0;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.B @(R0,Rm),Rn 0x0nmC
        else if ((raw & 0xF00F) == 0x000C)
        {
            ins.op = Op::LOAD8_R0;
            ins.dst.isImm = false; ins.dst.reg = n;      // Rn
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;    // Rm base
            INFO_LOG(SH4, "Emitter: Decoded LOAD8_R0 R%d <- @(R0,R%d) (0x%04X) at PC=0x%08X", n, m, raw, pc);
            decoded = true; blk.pcNext = pc + 2;
        }

        // MOV.W @(R0,Rm),Rn 0x0nmD
        else if ((raw & 0xF00F) == 0x000D)
        {
            ins.op = Op::LOAD16_R0;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            INFO_LOG(SH4, "Emitter: Decoded LOAD16_R0 R%d <- @(R0,R%d) (0x%04X) at PC=0x%08X", n, m, raw, pc);
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.L @(R0,Rm),Rn 0x0nmE
        else if ((raw & 0xF00F) == 0x000E)
        {
            ins.op = Op::LOAD32_R0;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // LDC.L @Rm+,SR  (0x4m3E)
        else if ((raw & 0xF0FF) == 0x403E)
        {
            ins.op = Op::LDC_SR_L;
            ins.src1.isImm = false;
            ins.src1.reg = (raw >> 8) & 0xF; // Rm
            ins.src1.type = RegType::GPR;
            // SR is the implicit destination
            // Rm is post-incremented by 4 by the executor
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MULU.W Rm,Rn 0x2nmE - Unsigned 16-bit multiply, result in MACL
        else if ((raw & 0xF00F) == 0x200E)
        {
            ins.op = Op::MULU_W;
            ins.dst.isImm = false; ins.dst.reg = n; // use dst as Rn
            ins.src1.isImm = false; ins.src1.reg = m; // src1 as Rm
            decoded = true;
            blk.pcNext = pc + 2;
            INFO_LOG(SH4, "Emitter: Decoded MULU.W R%u,R%u (0x%04X) at PC=0x%08X",
                     m, n, raw, pc);
        }
        // STS MACH,Rn 0x0n0A
        else if ((raw & 0x00FF) == 0x000A)
        {
            ins.op = Op::GET_MACH;
            ins.dst.isImm = false; ins.dst.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // STS MACL,Rn 0x0n1A
        else if ((raw & 0x00FF) == 0x001A)
        {
            ins.op = Op::GET_MACL;
            ins.dst.isImm = false; ins.dst.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // STS PR,Rn 0x0n2A
        else if ((raw & 0x00FF) == 0x002A)
        {
            ins.op = Op::GET_PR;
            ins.dst.isImm = false; ins.dst.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // STS.L PR,@-Rn  (0x4n22)
        else if ((raw & 0xF0FF) == 0x4022)
        {
            ins.op = Op::STS_PR_L;
            ins.dst.isImm = false; // Rn contains address
            ins.dst.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // LDS.L @Rn+,PR  (0x4n26)
        else if ((raw & 0xF0FF) == 0x4026)
        {
            ins.op = Op::LDS_PR_L;
            ins.src1.isImm = false; // Rn is address register
            ins.src1.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // LDC.L @Rn+,SSR  0x4n37
        else if ((raw & 0xF0FF) == 0x4037)
        {
            ins.op = Op::LDC_SSR_L;
            ins.src1.isImm = false;  // address in Rn
            ins.src1.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // LDC.L @Rn+,SPC  0x4n47
        else if ((raw & 0xF0FF) == 0x4047)
        {
            ins.op = Op::LDC_SPC_L;
            ins.src1.isImm = false;
            ins.src1.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // LDC.L @Rn+,SGR  0x4n36
        else if ((raw & 0xF0FF) == 0x4036)
        {
            ins.op = Op::LDC_SGR_L;
            ins.src1.isImm = false;
            ins.src1.reg = n;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // LDTLB (load TLB entry) 0x0038
        else if (raw == 0x0038)
        {
            ins.op = Op::LDTLB;
            decoded = true;
            blk.pcNext = pc + 2;
        }
        // MOV.B Rm,@Rn+ (0x2nm4)
        else if ((raw & 0xF00F) == 0x2004)
        {
            ins.op = Op::STORE8_POST;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.W Rm,@Rn+ (0x2nm5)
        else if ((raw & 0xF00F) == 0x2005)
        {
            ins.op = Op::STORE16_POST;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.L Rm,@Rn+ (0x2nm6)
        else if ((raw & 0xF00F) == 0x2006)
        {
            ins.op = Op::STORE32_POST;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            decoded = true; blk.pcNext = pc + 2;
        }
        // FPU single-precision arithmetic  (1111 nnnn mmmm xxxx)
        else if ((raw & 0xF000) == 0xF000)
        {

                {
                    uint8_t sub = raw & 0xF;    // low 4 bits give operation
                    switch (sub)
                    {
                    case 0x0:
                        // For double precision, the instruction format is FADD DRm,DRn
                        // Where DRm is source and DRn is destination (and also gets the result)
                        // For opcode 0xFCE0, m=7, n=6 -> FADD DR7,DR6 (DR6 = DR6 + DR7)
                        INFO_LOG(SH4, "FADD.d decoded");
                        ins.op = Op::FADD;
                        ins.dst.isImm = false; ins.dst.reg = n; ins.dst.type = RegType::FGR;
                        ins.src1.isImm = false; ins.src1.reg = m; ins.src1.type = RegType::FGR;
                        ins.src2.isImm = false;
                        ins.src2.reg = n;
                        break; // FADD FRm,FRn
                    case 0x1:
                        // For double precision, the instruction format is FSUB DRm,DRn
                        // Where DRm is source and DRn is destination (and also gets the result)
                        INFO_LOG(SH4, "FSUB.d decoded");
                        ins.op = Op::FSUB;
                        ins.dst.isImm = false; ins.dst.reg = n; ins.dst.type = RegType::FGR;
                        ins.src1.isImm = false; ins.src1.reg = m; ins.src1.type = RegType::FGR;
                        ins.src2.isImm = false;
                        ins.src2.reg = n;
                        break; // FSUB FRm,FRn
                    case 0x2:
                        // For double precision, the instruction format is FMUL DRm,DRn
                        // Where DRm is source and DRn is destination (and also gets the result)
                        INFO_LOG(SH4, "FMUL.d decoded");
                        ins.op = Op::FMUL;
                        ins.dst.isImm = false; ins.dst.reg = n; ins.dst.type = RegType::FGR;
                        ins.src1.isImm = false; ins.src1.reg = m; ins.src1.type = RegType::FGR;
                        ins.src2.isImm = false;
                        ins.src2.reg = n;
                        break; // FMUL FRm,FRn
                    case 0x3:
                        // For double precision, the instruction format is FDIV DRm,DRn
                        // Where DRm is source and DRn is destination (and also gets the result)
                        INFO_LOG(SH4, "FDIV.d decoded");
                        ins.op = Op::FDIV;
                        ins.dst.isImm = false; ins.dst.reg = n; ins.dst.type = RegType::FGR;
                        ins.src1.isImm = false; ins.src1.reg = m; ins.src1.type = RegType::FGR;
                        ins.src2.isImm = false;
                        ins.src2.reg = n;
                        break; // FDIV FRm,FRn
                    case 0x4:
                        ins.op = Op::FCMP_EQ;
                        ins.dst.isImm = false; ins.dst.reg = n; ins.dst.type = RegType::FGR;
                        ins.src1.isImm = false; ins.src1.reg = m;
                        ins.src2.isImm = false;
                        ins.src2.reg = n; ins.src1.type = RegType::FGR;
                        break; // FCMP/EQ FRm,FRn
                    case 0x5:
                        ins.op = Op::FCMP_GT;
                        ins.dst.isImm = false; ins.dst.reg = n; ins.dst.type = RegType::FGR;
                        ins.src1.isImm = false; ins.src1.reg = m;
                        ins.src2.isImm = false;
                        ins.src2.reg = n; ins.src1.type = RegType::FGR;
                        break; // FCMP/GT FRm,FRn

                    case 0x6: // FSQRT single or FMOV.S @Rm+,FRn depending on m==n
                        if (m == n) {
                            // FSQRT FRn (square root)
                            ins.op = Op::FSQRT;
                            ins.dst.isImm = false; ins.dst.reg = n;
                        } else {
                            // FMOV.S @Rm+,FRn (post-increment load)
                            ins.op = Op::FMOV;
                            ins.dst.isImm = false; ins.dst.reg = n; // FRn
                            ins.src1.isImm = false; ins.src1.reg = m;
                            ins.src2.isImm = false;
                            ins.src2.reg = n; // Rm address base
                            ins.dst.type = RegType::FGR;
                            ins.src1.type = RegType::GPR;
                            ins.extra = 1; // post-increment flag
                            DEBUG_LOG(SH4, "Emitter::CreateNew: Decoded FMOV.S @R%u+,FR%u (subcode 6) at PC=0x%08X", m, n, pc);
                        }
                        break;
                    case 0x7: // FABS FRm,FRn (absolute value)
                        ins.op = Op::FABS;
                        ins.dst.isImm = false; ins.dst.reg = n;
                        ins.src1.isImm = false; ins.src1.reg = m;
                        ins.src2.isImm = false;
                        ins.src2.reg = n;
                        break;
                    case 0x8: // FMOV.S @(R0,Rm),FRn
                        ins.op = Op::FMOV_LOAD_R0;
                        ins.dst.isImm = false; ins.dst.reg = n; // FRn
                        ins.src1.isImm = false; ins.src1.reg = m;
                        ins.src2.isImm = false;
                        ins.src2.reg = n; // Rm for address offset
                        break;
                    case 0x9: // FMOV.S FRm,@(R0,Rn)
                        ins.op = Op::FMOV_STORE_R0;
                        ins.dst.isImm = false; ins.dst.reg = n; // Rn provides offset for store address
                        ins.src1.isImm = false; ins.src1.reg = m;
                        ins.src2.isImm = false;
                        ins.src2.reg = n; // FRm source value register
                        break;
                    case 0xA: // FLDS FRm,FPUL
                        ins.op = Op::FLDS;
                        ins.src1.isImm = false; ins.src1.reg = m;
                        ins.src2.isImm = false;
                        ins.src2.reg = n; // FRm source
                        ins.src1.type = RegType::FGR;
                        break;
                    case 0xB: // FMOV FRm,FRn (register-to-register move)
                        ins.op = Op::FMOV;
                        ins.dst.isImm = false; ins.dst.reg = n;
                        ins.src1.isImm = false; ins.src1.reg = m;
                        ins.src2.isImm = false;
                        ins.src2.reg = n;
                        ins.dst.type = RegType::FGR;
                        ins.src1.type = RegType::FGR;
                        break;
                    case 0xC: // FLDI0 / FLDI1 depending on m
                        ins.op = (m == 0) ? Op::FLDI0 : (m == 1) ? Op::FLDI1 : Op::ILLEGAL;
                        ins.dst.isImm = false; ins.dst.reg = n; // FRn target
                        ins.dst.type = RegType::FGR;
                        break;
                        case 0xD:   // assorted “…D” FPU ops (FLOAT / FCNVSD / FSQRT.d / etc.)
                        {
                            // 1. FLOAT   FPUL -> DRn     (m == 2)
                             // 2. FCNVSD  FPUL -> DRn     (m == 0xA)
                             if (m == 2) {
                                   ins.op = Op::FLOAT;
                                   ins.dst = {false, static_cast<u8>(n >> 1), RegType::FGR};
                             }
                             else if (m == 0xA) {
                                   ins.op = Op::FCNVSD;
                                   ins.dst = {false, static_cast<u8>(n >> 1), RegType::FGR};
                             }
                             else if (m == 0xB) {
                                   ins.op = Op::FCNVDS;
                                   ins.src1 = {false, n, RegType::FGR}; // DRn source encoded via n
                             }
                            // 2. FSQRT.d DRn                (m == 6)
                            else if (m == 6) {
                                INFO_LOG(SH4, "FSQRT.d DR%d decoded (0x%04X)", n >> 1, raw);
                                ins.op = Op::FSQRT;
                                ins.dst = {false, n, RegType::FGR};
                            }
                            // 3. Other “…D” single-reg ops – dispatch on bits 7-4
                            else {
                                switch ((raw >> 4) & 0xF) {
                                    case 0x1:  ins.op = Op::FLDS;  ins.src1 = {false, m, RegType::FGR};               break;
                                    case 0x2:  ins.op = Op::FLOAT; ins.dst  = {false, n, RegType::FGR};               break;
                                    case 0x3:  ins.op = Op::FTRC;  ins.src1 = {false, static_cast<uint8_t>(n), RegType::FGR};               break;
                                    case 0x4:  ins.op = Op::FNEG;  ins.dst  = {false, n, RegType::FGR};               break;
                                    case 0x5:  ins.op = Op::FABS;  ins.dst  = {false, n, RegType::FGR};               break;
                                    case 0xD:  ins.op = Op::FSTS;  ins.dst  = {false, n, RegType::FGR};               break;
                                    default:   ins.op = Op::ILLEGAL;                                                break;
                                }
                            }
                            break;
                        }
                        // Removed duplicate FSQRT.d decode path - now handled in case 0xD above
                        // (FNEG, FABS, FLDS, FLOAT, etc.)
                        // Floating point opcodes ending in D (F...D)
                        switch ((raw >> 4) & 0xF)
                        {
                            case 1: // FLDS FRm, FPUL (0xFm1D)
                                ins.op = Op::FLDS;
                                ins.src1.reg = (raw >> 8) & 0xF;
                                ins.src1.isImm = false;
                                ins.src1.type = RegType::FGR;
                                DEBUG_LOG(SH4, "Emitter::CreateNew: Decoded FLDS FR%u, FPUL (0x%04X) at PC=0x%08X", ins.src1.reg, raw, pc);
                                break;

                            case 2: // FLOAT FPUL, FRn (0xFn2D)
                                ins.op = Op::FLOAT;
                                // Extract destination register from bits 8-11
                                ins.dst.reg = (raw >> 8) & 0xF;
                                ins.dst.isImm = false;
                                ins.dst.type = RegType::FGR;
                                // For opcode 0xFC2D, this should be 12 (0xC) for DR6
                                DEBUG_LOG(SH4, "Emitter::CreateNew: Decoded FLOAT FPUL, FR%u (0x%04X) at PC=0x%08X", ins.dst.reg, raw, pc);
                                break;

                            case 3: // FTRC FRm, FPUL (0xFm3D)
                                ins.op = Op::FTRC;
                                ins.src1.reg = (raw >> 8) & 0xF;
                                ins.src1.isImm = false;
                                ins.src1.type = RegType::FGR;
                                DEBUG_LOG(SH4, "Emitter::CreateNew: Decoded FTRC FR%u, FPUL (0x%04X) at PC=0x%08X", ins.src1.reg, raw, pc);
                                break;

                            case 4: // FNEG FRn (0xFn4D)
                                ins.op = Op::FNEG;
                                ins.dst.reg = (raw >> 8) & 0xF;
                                ins.dst.isImm = false;
                                ins.dst.type = RegType::FGR;
                                DEBUG_LOG(SH4, "Emitter::CreateNew: Decoded FNEG FR%u (0x%04X) at PC=0x%08X", ins.dst.reg, raw, pc);
                                break;

                            case 5: // FABS FRn (0xFn5D)
                                ins.op = Op::FABS;
                                ins.dst.reg = (raw >> 8) & 0xF;
                                ins.dst.isImm = false;
                                ins.dst.type = RegType::FGR;
                                DEBUG_LOG(SH4, "Emitter::CreateNew: Decoded FABS FR%u (0x%04X) at PC=0x%08X", ins.dst.reg, raw, pc);
                                break;

                            case 0xD: // FSTS FPUL,FRn (0xFnDD)
                                ins.op = Op::FSTS;
                                ins.src1.reg = (raw >> 8) & 0xF; // Destination register in src1, as per original code and executor
                                ins.src1.isImm = false;
                                ins.src1.type = RegType::FGR;
                                DEBUG_LOG(SH4, "Emitter::CreateNew: Decoded FSTS FPUL,FR%u (0x%04X) at PC=0x%08X", ins.src1.reg, raw, pc);
                                break;

                            default:
                                ins.op = Op::ILLEGAL;
                                break;
                        }
                        break;
                    default:  ins.op = Op::ILLEGAL; break; // other 0xF subcodes not handled yet
                    }
                }
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.W @Rm,Rn (0x6nm1)
        else if ((raw & 0xF00F) == 0x6001)
        {
            ins.op = Op::LOAD16;
            ins.dst.isImm = false; ins.dst.reg = n;
            ins.src1.isImm = false; ins.src1.reg = m;
            ins.src2.isImm = false;
            ins.src2.reg = n;
            ins.extra = 0;
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.B @(disp,Rm),R0 0x84md
        else if ((raw & 0xFF00) == 0x8400)
        {
            uint8_t disp4 = raw & 0xF;
            uint8_t m_reg = (raw >> 4) & 0xF;
            ins.op = Op::LOAD8;
            ins.dst.isImm = false; ins.dst.reg = 0; // R0
            ins.src1.isImm = false; ins.src1.reg = m_reg;
            ins.extra = disp4; // byte displacement
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.W @(disp,Rm),R0 0x85md
        else if ((raw & 0xFF00) == 0x8500)
        {
            uint8_t disp4 = raw & 0xF;
            uint8_t m_reg = (raw >> 4) & 0xF;
            ins.op = Op::LOAD16;
            ins.dst.isImm = false; ins.dst.reg = 0;
            ins.src1.isImm = false; ins.src1.reg = m_reg;
            ins.extra = disp4 * 2;
            decoded = true; blk.pcNext = pc + 2;
        }
        // MOV.L @(disp,Rm),R0 0x86md
        else if ((raw & 0xFF00) == 0x8600)
        {
            uint8_t disp4 = raw & 0xF;
            uint8_t m_reg = (raw >> 4) & 0xF;
            ins.op = Op::LOAD32;
            ins.dst.isImm = false; ins.dst.reg = 0;
            ins.src1.isImm = false; ins.src1.reg = m_reg;
            ins.extra = disp4 * 4;
            decoded = true; blk.pcNext = pc + 2;
        }


        // ----------------------------------------------------------------
        //  Fail-safe: if still not decoded, treat as NOP so execution
        //  continues instead of throwing an IllegalInstr exception that
        //  trips the fatal error inside BIOS padding or unknown areas.
        // ----------------------------------------------------------------
        if (!decoded)
        {
            fatal_error("Emitter::CreateNew: ILLEGAL opcode raw=0x%04X at PC=0x%08X", raw, pc);
            ins.op = Op::ILLEGAL;
            decoded = true;
            blk.pcNext = pc + 2;
        }

        // If we decoded something (including NOP fallback), push instruction
        if (decoded)
        {
            ins.pc = pc;
            ins.raw = raw;
            blk.code.push_back(ins);

            INFO_LOG(SH4, "Emitter::CreateNew: Before delay slot check for PC=0x%08X, main_raw=0x%04X. blk.pcNext=0x%08X, expected_pc_plus_4=0x%08X", pc, raw, blk.pcNext, pc + 4);
            // If instruction has delay slot, append slot instruction
            if (blk.pcNext == pc + 4)
            {
                uint32_t slot_pc = pc + 2;
                uint16_t slot_raw = mmu_IReadMem16(slot_pc);
                Instr slot{};
                // Make sure the slot carries its own PC and raw encoding so the executor
                // can correctly attribute the instruction.  Omitting this caused the slot
                // to appear as PC=0 and raw=0, eventually leading to a bogus branch target
                // and a crash when the executor tried to run from the null page.
                slot.pc  = slot_pc;
                slot.raw = slot_raw;
                INFO_LOG(SH4, "Emitter::DelaySlot: Decoding for slot_pc=0x%08X, slot_raw=0x%04X", slot_pc, slot_raw);
                // Use a dummy block so that FastDecode does not overwrite blk.pcNext (which already
                // contains the *branch* target calculated by the main instruction). Overwriting it
                // with slot_pc+2 would nullify the branch and eventually crash when execution falls
                // through past valid code.
                Block dummy_slot_blk_for_decode{};
                bool slot_decoded_fast = FastDecode(slot_raw, slot_pc, slot, dummy_slot_blk_for_decode);
                INFO_LOG(SH4, "Emitter::DelaySlot: FastDecode returned %d, slot.op=%d (expected MOV_REG=%d), blk.pcNext=0x%08X", slot_decoded_fast, static_cast<int>(slot.op), static_cast<int>(Op::MOV_REG), blk.pcNext);
                if (!slot_decoded_fast)
                {
                    // Attempt manual decode for the slot if FastDecode failed
                    // This is a simplified version; a more robust solution might involve calling a subset of manual decoders
                    if ((slot_raw & 0xF00F) == 0x6003) { // MOV_REG Rm, Rn (MOV R0,R2 -> 0x6023)
                        slot.op = Op::MOV_REG;
                        slot.dst.isImm = false; slot.dst.reg = (slot_raw >> 8) & 0xF; // Rn
                        slot.src1.isImm = false; slot.src1.reg = (slot_raw >> 4) & 0xF; // Rm
                        INFO_LOG(SH4, "Emitter::DelaySlot: Manually decoded MOV_REG (0x%04X) for slot. slot.op=%d", slot_raw, static_cast<int>(slot.op));
                    }
                    // FMOV FRm,FRn (0xFnnB)
                    else if ((slot_raw & 0xF00F) == 0xF00B)
                    {
                        slot.op = Op::FMOV;
                        slot.dst.isImm = false; slot.dst.reg = (slot_raw >> 8) & 0xF; // FRn
                        slot.src1.isImm = false; slot.src1.reg = (slot_raw >> 4) & 0xF; // FRm
                        slot.dst.type = RegType::FGR;
                        slot.src1.type = RegType::FGR;
                        INFO_LOG(SH4, "Emitter::DelaySlot: Manually decoded FMOV FR%d,FR%d (0x%04X) for slot.", slot.src1.reg, slot.dst.reg, slot_raw);
                    }
                    else {
                        ERROR_LOG(SH4, "Emitter::DelaySlot: ILLEGAL opcode raw=0x%04X at slot PC=0x%08X", slot_raw, slot_pc);

                        slot.op = Op::ILLEGAL;
                        // If the delay slot itself causes a change in pcNext (e.g. another branch), that's complex and not handled here simply.
                        // For now, assume delay slot is simple and doesn't alter flow beyond what main branch dictates.
                        // However, if it's truly illegal, the block's pcNext might need to point after the illegal slot instruction.
                        // This was: blk.pcNext = slot_pc + 2; - let's see if removing it helps, relying on main branch's pcNext.
                        INFO_LOG(SH4, "Emitter::DelaySlot: Slot instruction 0x%04X at 0x%08X is ILLEGAL after FastDecode failed.", slot_raw, slot_pc);
                    }
                }
                blk.code.push_back(slot);
                INFO_LOG(SH4, "Emitter::DelaySlot: Pushed slot.op=%d. Final blk.pcNext for main block (PC=0x%08X) is 0x%08X", static_cast<int>(slot.op), pc, blk.pcNext);
            }

            Instr end{}; end.op = Op::END; end.pc = blk.pcNext; end.raw = 0xFFFF;
            blk.code.push_back(end);
            INFO_LOG(SH4, "Emitter::CreateNew: Finalizing block for PC=0x%08X. Instructions: %zu. pcNext=0x%08X", blk.pcStart, blk.code.size(), blk.pcNext);
    fflush(stdout);
    g_block_sig_cache.emplace(sig, &blk);
    return blk;
        }
    }
    return blk;
}

const Block* Emitter::BuildBlock(uint32_t pc)
{
    // Calculate signature of current code at PC
    uint64_t current_sig = CalcBlockSig(pc);

    auto it = cache_.find(pc);
    if (it != cache_.end()) {
        // Block exists in cache, but check if code has changed
        uint64_t cached_sig = 0;
        auto sig_it = g_block_sig_cache.begin();
        for (; sig_it != g_block_sig_cache.end(); ++sig_it) {
            if (sig_it->second == &it->second) {
                cached_sig = sig_it->first;
                break;
            }
        }

        // If signatures match, code hasn't changed, return cached block
        if (sig_it != g_block_sig_cache.end() && cached_sig == current_sig) {
            return &it->second;
        }

        // Code has changed, remove old entry and rebuild
        if (sig_it != g_block_sig_cache.end()) {
            g_block_sig_cache.erase(sig_it);
        }
        cache_.erase(it);
        INFO_LOG(SH4, "Emitter detected self-modifying code at PC=0x%08X, rebuilding block", pc);
    }

    return &CreateNew(pc);
}

void Emitter::EmitInstr(Block&, uint16_t) {
    // TODO: real decode later
}

} // namespace ir
} // namespace sh4
